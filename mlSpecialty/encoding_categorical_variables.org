
* Encoding Categorical Variables
### Encoding categorical variables with Python

** Introduction
Categorical data is data that has more than one category. When working with that type of data we have two types, nominal and ordinal. Nominal data is data that has no particular order or hierarchy to it, and ordinal data is categorical data where the categories have order, but the differences between the categories are not important or unclear.

We will be working with a dataset of used cars for this article to truly understand and demonstrate how to work with categorical data. Let's explore it and see what type of data we are working with.

#+begin_src python :results output
  import pandas as pd

  #import data
  cars = pd.read_csv('cars.csv')

  #check variable types
  print(cars.dtypes)

#+end_src

#+RESULTS:
#+begin_example
Unnamed: 0        int64
year              int64
make             object
model            object
trim             object
body             object
transmission     object
vin              object
state            object
condition       float64
odometer        float64
color            object
interior         object
seller           object
mmr               int64
sellingprice      int64
saledate         object
Unnamed: 16     float64
dtype: object
#+end_example

We can see from the output that we have a lot of features that are ~dtype = object~ and that tells us those features could be text or a mix of text and numerical values. For our encoding examples, we will explore a few of those object features and transform those values so we can have a data frame ready form machine learning.

The reason we put our time into this level of encoding is that there are many machine learning models that cannot handle text and will only work with numbers. Our data must be encoded into numbers before we even begin to train, test or evaluate a model.

** Ordinal encoding
We mentioned already that ordinal data is data that does have order and a hierarchy between its values. Let us take a look at the ~condition~ feature from our data frame and perform a value_counts to see how many times each labels is listed in our feature.

#+begin_src python :results output
  import pandas as pd

  #import data
  cars = pd.read_csv('cars.csv')

  #check variable types
  print(cars.dtypes)

  #howmany times each label is listed in our feature
  print(cars['condition'].value_counts())
#+end_src

#+RESULTS:
#+begin_example
Unnamed: 0        int64
year              int64
make             object
model            object
trim             object
body             object
transmission     object
vin              object
state            object
condition       float64
odometer        float64
color            object
interior         object
seller           object
mmr               int64
sellingprice      int64
saledate         object
Unnamed: 16     float64
dtype: object

# #OUTPUT
# New          2881
# Like New     2860
# Good         2027
# Fair          753
# Excellent     18
#+end_example

This is definitely an example of ordinal data: the condition of the used cars can easily be put in order of those in the “best” condition to the cars in the “worst” condition. The output printed the labels with the highest counts, but we can assume the following hierarchy:

    Excellent
    New
    Like New
    Good
    Fair

We need to convert these labels into numbers, and we can do this with two different approaches. First, we can do this by creating a dictionary where every label is the key and the new numeric number is the value. 'Excellent' will get the highest score and 'Fair' will be our lowest score. Then we will map each label from the condition column to the numeric value and create a new column called condition_rating.

#+begin_src python
  #create dictionary of label:values in order
  rating_dict = {'Excellent':5, 'New':4, 'Like New':3, 'Good':2, 'Fair':1}

  #create a new column
  cars['condition_rating'] = cars['condition'].map(rating_dict)
#+end_src

The second approach we will show is how to utilize the sklearn.preprocessing library OrdinalEncoder. We follow a similar approach: we set our categories as a list, and then we will .fit_transform the values in our feature condition. We need to make sure we adhere to the shape requirements of a 2-D array, so you'll notice the method .reshape(-1,1).

We'll also note, this method will not work if your feature has NaN values. Those need to be addressed prior to running .fit_transform.

#+begin_src python
  #using scikit-learn
  from sklearn.preprocessing import OrdinalEncoder

  #create encoder and set category order
  encoder = OrdinalEncoder(categories=[['Excellent', 'New', 'Like New', 'Good', 'Fair']])

  #reshape our feature
  condition_reshaped = cars['condition'].values.reshape(-1,1)

  #create a new variable with assigned numbers
  cars['condition_rating'] = encoder.fit_transform(condition_reshaped)
#+end_src
