
* SQL
Like most organizations, Codecademy uses SQL (Structured Query Language) to access its database.

A *database* is a set of data stored in a computer. This data is usually structured into /tables/. Tables can grow large and have a multitude of columns and records.

Spreadsheets, like Microsoft Excel and Google Sheets, allow you to view and manipulate data directly: with selecting, filtering, sorting, etc. By applying a number of these operations you can obtain the subset of data you are seeking.

SQL (pronounced “S-Q-L” or “sequel”) allows you to write queries which define the subset of data you are seeking. Unlike Excel and Sheets, your computer and SQL will handle how to get the data; you can focus on what data you would like. You can sabe these queries, refine them, share them, and run them on different databases.

It is a great way to access data and a great entry point to programming because its syntax (the specific vocabulary that gives instructions to the computer) is very human-readable. Without knowing any SQL, you might still be able to guess what each command will do.

* Relational Databases
A relational database is a database that organizes information into one or more tables.

A /table/ is a collection of data organized into rows and columns. Tables are sometimes referred to as /relations/.

A /column/ is a set of data values of a particular type. By example id, name and age.

A /row/ is a single record in a table.

All data stored in a relational database is of a certain data type. Some of the most common data types are:

    - INTEGER, a positive or negative whole number

    - TEXT, a text string

    - DATE, the date formatted as YYYY-MM-DD

    - REAL, a decimal value

* Statements
The code below is a SQL statement. A /statement/ is text that the database recognizes as a valid command. Statements always end in a semicolon ~;~.

#+begin_src
CREATE TABLE table_name (
  column_1 data_type,
  column_2 data_type,
  column_3 data_type
  );
#+end_src

Let's break down the components of a statement:

    1. ~CREATE TABLE~ is a /clause/. Clauses perform specific tasks in SQL. By convention, clauses are written in capital letters. Clauses can also be referred to as commands.

    2. ~table_name~ refers to the name of the table that the command is applied to.

    3. ~(column_1 data_type, column_2 data_type, column_3 data_type)~ is a /parameter/. A parameter is a list of columns, data types, or values that are passed to a clause as an argument. Here, the parameter is a list of column names and the associated data type.

The structure od SQL statements vary. The number of lines used does not matter. A statement can be written all on one line, or split up across multiple lines if it makes it easier to read.

** Create
CREATE statements allow us to create a new table in the database. You can use the CREATE statement anytime you want to create a new table from scratch. The statement below creates a new table named ~celebs~.

#+begin_src
CREATE TABLE celebs (
  id INTEGER,
  name TEXT,
  age INTEGER
  );
#+end_src

1. ~CREATE TABLE~ is a clause that tells SQL you want to create a new table.

2. ~celebs~ is the name of the table.

3. ~(id INTEGER, name TEXT, age INTEGER)~ is a list of parameters defining each column, or attribute in the table and its data type:

    ~id~ is the first column in the table. It stores values of data type INTEGER
    ~name~ is the second column in the table. It stores values of data type TEXT
    ~age~ is the third column in the table. It stores values of data type INTEGER

** Insert
The INSERT statement inserts a new row into a table.

We can use the INSERT statement when you want to add new records.

#+begin_src
INSERT INTO celebs (id, name, age)
VALUES (1, 'Justin Bieber', 22);
INSERT INTO celebs (id, name, age)
VALUES (2, 'Beyonce Knowles', 33);
INSERT INTO celebs (id, name, age)
VALUES (3, 'Jeremy Lin', 26);
INSERT INTO celebs (id, name, age)
VALUES (4, 'Taylor Swift', 26);
#+end_src

    - ~INSERT INTO~ is a clause that adds the specified row or rows.

    - ~celebs~ is the table the row is added to.

    - ~(id, name, age)~ is a parameter identifying the columns that data will be inserted into.

    - ~(1, 'Justin Bieber', 29)~ is a parameter identifying the values being inserted.

        - ~1~: an integer that will be added to id column
        - ~'Justin Bieber'~: text that will be added to name column
        - ~29~: an integer that will be added to age column

** Select
SELECT statements are used to fetch data from a database. In the statement below, SELECT returns all data in the ~name~ column of the ~celebs~ table.

#+begin_src
SELECT name FROM celebs;
#+end_src

1. SELECT is a clause that indicates that the statement is a query. You will use SELECT every time you query data from a database.

2. ~name~ specifies the column to query data from.

3. FROM celebs specifies the name of the table to query data from. In this statement, data is queried from the celebs table.

You can also query data from all columns in a table with SELECT.

#+begin_src
SELECT * FROM celebs;
#+end_src

~*~ is a special wildcard character that we have been using. It allows you to select every column in a table without having to name each one individually. Here, the result set contains every column in the ~celebs~ table.

SELECT statements always return a new table called the /result set./

** Alter
The ALTER TABLE statement add a new column to a table. You can use this command when you want to add columns to a table. The statement below add a new column twitter_handle to the celebs table.

#+begin_src
ALTER TABLE celebs
  ADD COLUMN twitter_handle TEXT;
#+end_src

1. ALTER TABLE is a clause that lets you make the specified changes.

2. celebs is the name of the table that is being changed.

3. ADD COLUMN is a clause that lets you add a new column to a table:

       - twitter_handle is the name of the new column being added

       - TEXT is the data type for the new column

4. NULL is a special value in SQL that represents missing or unknown data. Here, the rows that existed before the column was added have NULL ($\emptyset$) values for ~twitter_handle~.

** Update
The UPDATE statement edits a row in a table. You can use the UPDATE statement when you want to change existing records. The statement below updates the record with an ~id~ value of ~4~ to have the ~twitter_handle @taylorswift13~.

#+begin_src
UPDATE celebs
  SET twitter_handle = '@taylorswift13'
  WHERE id = 4;
#+end_src

1. UPDATE is a clause that edits a row in the table.
2. ~celebs~ is the name of the table.
3. SET is a clause that indicates the column to edit.

       - ~twitter_handle~ is the name of the column that is going to be updated

       - ~@taylorswift13~ is the new value that is going to be inserted into the ~twitter_handle~ column.

4. WHERE is a clause that indicates which row(s) to update with the new column value. Here the row with a ~4~ in the ~id~ column is the row that will have the twitter_handle updated to @taylorswift13.

** Delete
The DELETE FROM statement deletes one or more rows from a table. You can use the statement when you want to delete existing records. The statement below deletes all records in the ~celebs~ table with no ~twitter_handle~:

#+begin_src
DELETE FROM celebs
  WHERE twitter_handle IS NULL;
#+end_src

1. DELETE FROM is a clause that lets you delete rows from a table.

2. ~celebs~ is the name of the table we want to delete rows from.

3. WHERE is a clause that lets you select which rows you want to delete. Here we want to delete all of the rows where the ~twitter_handle~ column IS NULL.

4. IS NULL is a condition in SQL that returns true when the value is NULL and false otherwise.

** Constrains
Constrains that add information about how a column can be used are invoked after specifying the data type for a column. They can be used to tell the database to reject inserted data that does not adhere to a certain restriction. The statement below sets /constrains/ on the ~celebs~ table.

#+begin_src
CREATE TABLE celebs (
  id INTEGER PRIMARY KEY,
  name TEXT UNIQUE,
  date_of_birth TEXT NOT NULL,
  data_of_death TEXT DEFAULT 'Not Applicable'
  );
#+end_src

1. PRIMARY KEY columns can be used to uniquely identify the row. Attempts to insert a row with an identical value to a row already in the table will result in a /constrain violation/ which will not allow you to insert the new row.

2. UNIQUE columns have a different value for every row. This is similar to PRIMARY KEY except a table can have many different UNIQUE columns.

3. NOT NULL columns must have a value. Attempts to insert a row without a value for a NOT NULL column will result in a constrain violation and the new row will not be inserted.

4. DEFAULT columns take an additional argument that will be the assumed value for an inserted row if the new row does not specify a value for that column.

** Review
SQL is a programming language designed to manipulate and manage data stored in relational databases.

    - A /relational database/ is a database that organizes information into one or more tables.

    - A /table/ is a collection of data organized into rows and columns.

A /statement/ is a string of characters that the database recognizes as a valid command.

    - CREATE TABLE creates a new table.

    - INSERT INTO adds a new row to a table.

    - SELECT queries data from a table.

    - ALTER TABLE changes an existing table.

    - UPDATE edits a row in a table.

    - DELETE FROM deletes rows from a table.

Constrains add information about how a column can be used.

** Quiz

*** Question 1
What is the purpose of the * character?

#+begin_src
SELECT * FROM celebs;
#+end_src

    - It selects every column in a table.
      Correct! It allows us to select /every/ column in a table without having to name each one individually.

*** Question 2
What does the INSERT statement do?

    - Insert new rows into a table.

*** Question 3
What is a relational database?

    - A relational database is a database that organizes information into one or more tables

*** Question 4
What is a NULL value?

    - A value that represents missing or unknown data.

*** Question 5
What would be correct syntax for a CREATE TABLE statement?

    #+begin_src
    CREATE TABLE meals (
      name TEXT,
      rating INTEGER
    );
    #+end_src

*** Question 6
What is SQL?

    - Structured Query Language
      Correct! SQL is a programming language designed to manage data stored in relational databases.

*** Question 7
What would you need to complete the associated UPDATE statement?

#+begin_src
UPDATE table name
SET height = 6
WHERE id = 1;
#+end_src

*** Question 8
Which of the following statements is correct and complete?

#+begin_src
DELETE FROM icecream
  WHERE flavor IS NULL;
#+end_src

*** Question 9
What clause is used with the ALTER TABLE statement?

    - ADD COLUMN

*** Question 10
What are common data types in SQL?

    - Integer, Text, Date, and Real
      Integer - a whole number. Text - a text string. Date - a date. Real - a decimal number.

* What is a Database Index?
Learn how database indexes help us quickly query data.

** What are indexes?
/Indexes/ are a powerful tool used in the background of a database to speed up querying. Indexes power queries by providing a method to quickly lookup the requested data.

Simply put, an index is a pointer to data in a table. An index in a database is very similar to an index in the back of a book.

** Why are indexes needed?
Imagine walking into the Library of Congress and being given the task to find a specific publishing within 10 minutes. Would you be able to complete this task within the given time frame? The Library of Congress is considered the largest library in the world and it houses approximately 170 million items.

Now, the Library of Congress is not a regular library where the public can check out books at will, but if you are like us, you know the challenge should not be too difficult. In fact, the first thing we would do is ask for access to the library's index because indexes contain all the necessary information needed to access items quickly and efficiently.

In the same manner, a database index contains all the necessary information to access data quickly and efficiently. In today's society, the business of data is rapidly advancing. In fact, some tech giants process several hundreds petabytes (1000⁵ bytes) of data per day. Storing all of this data in a database is great, but for a data company, being able to access that data efficiently is paramount to success. Just like the Library of Congress example, one way of solving the access issue when it comes to large amounts of data is through the use of indexes. Indexes serve as lookup tables that efficiently store data for quicker retrieval.

** How are indexes created?
In a database, data is stored in rows which are organized into tables. Each row has a unique key which distinguishes it from all other rows and those keys are stored in an index for quick retrieval.

Since keys are stored in indexes, each time a new row with a unique key is added, the index is automatically updated. However, sometimes we need to be able to quickly lookup data that is not stored as a key. For example, we may need to quickly lookup customers by telephone number. It would not be a good idea to use a unique constraint because we can have multiple customers with the same phone number. In these cases, we can create our own indexes.

The syntax for creating an index will vary depending on the database. However, the sintax typically includes a CREATE keyword followed by the INDEX keyword and the name we'd like to use for the index. Next should come the ON keyword followed by the name of the table that has the data we'd like to quickly access. Finally, the last part of the statement should be the name(s) of the columns to be indexed.

#+begin_src
CREATE INDEX <index_name>
  ON <table_name> (column1, column2, ...)
#+end_src

For example, if we would like to index phone numbers from a ~customers~ table, we could use the following statement:

#+begin_src
CREATE INDEX customers_by_phone
  ON customers (phone_number)
#+end_src

The users cannot see the indexes, they are just used to speed up searches/queries.

*Note:* Updating a table with indexes takes more time than updating a table without (because the indexes also need an update). So, only create indexes on columns that will be frequently searched against.

** Summary
This article was designed to give you an overview of database indexes, including how:

    - Indexes are a powerful tool used in the background of a database to speed up querying.

    - Indexes contain all the necessary information needed to access items quickly and efficiently.

    - Indexes serve as lookup tables to efficiently store data for quicker retrieval.

    - Table keys are stored in indexes.

    - Indexes for non-key values can be created with a CREATE INDEX statement.

* Writing Basic Queries
In this lesson, we will be learning different SQL commands to *query* a single table in a database.

One of the core purposes of the SQL language is to retrieve information stored in a database. This is commonly referred to as querying. Queries allow us to communicate with the database by asking questions and returning a result set with data relevant to the question.

We will be querying a database with one table named movies.

** Select
Previously, we learned that SELECT is used every time you want to query data from a database and * means all columns.

Suppose we are only interested in two of the columns. We can select individual columns by their names (separated by a comma):

#+begin_src
SELECT column1, column2
  FROM table_name;
#+end_src

To make it easier to read, we moved FROM to another line.

Line breaks don't mean anything specific in SQL. We could write this entire query in one line, and it would run just fine.

*** Task 1
Let's only select the name and genre columns of the table.

#+begin_src
SELECT name, genre
  FROM movies;
#+end_src

*** Task 2
Now we want to include a third column.

Edit your query so that it returns the name, genre, and year columns of the table.

#+begin_src
SELECT column1, column2, column3
  FROM table_name;
#+end_src

** As
Knowing how SELECT works, suppose we have the code below:

#+begin_src
SELECT names AS 'Titles'
  FROM movies;
#+end_src

Can you guess what AS does?

AS is a keyword in SQL that allows you to /rename/ a column or table using an alias. The new name can be anything you want as long as you put it inside of single quotes. Here we renamed the name column as Titles.

Some important things to note:

    - Although it's not always necessary, it is considered best practice to surround your aliases with single quotes.

          - Note that this practice is specific to SQLite, the RDBMS used in this exercise. When you work with other RDBMSs, notably PostgreSQL, no quotes or double quotes may be required in place of single quotes.

          - When using AS, the columns are not being renamed in the table. The aliases only appear in the result.

*** Task 1
To showcase what the AS keyword does, select the name column and rename it with an alias of your choosing.

Place the alias inside single quotes, like so:

#+begin_src
SELECT name AS '___'
  FROM movies;
#+end_src

Note in the result, that the name of the column is now your alias.

*** Task 2
Edit the query so that instead of selecting and renaming the name column, select the imdb_rating column and rename it IMDb.

#+begin_src
SELECT imdb_rating AS 'IMDb'
  FROM movies;
#+end_src

** Distinct
When we are examining data in a table, it can be helpful to know what /distinct/ values exist in a particular column.

DISTINCT is used to return unique values in the output. It filters out all duplicate values in the specified column(s).

For instance,

#+begin_src
SELECT tools
  FROM inventory;
#+end_src

might produce:

tools
Hammer
Nails
Nails
Nails

By adding DISTINCT before the column name,

#+begin_src
SELECT DISTINCT tools
  FROM inventory;
#+end_src

The result would now be:

tools
Hammer
Nails

Filtering the results of a query is an important skill in SQL. It is easier to see the different possible genres in the movie table after the data has been filtered than to scan every row in the table.

*** Task 1
Let's try it out. In the code editor, type:

#+begin_src
SELECT DISTINCT genre
  FROM movies;
#+end_src

*** Task 2
Now, change the code so we return the unique values of the year column instead.

#+begin_src
SELECT DISTINCT year
  FROM movies;
#+end_src

** Where
We can restrict our query results using the WHERE clause in order to obtain only the information we want.

Following this format, the statement below filters the result set to only include top rated movies (IMDb ratings greater than 8):

#+begin_src
SELECT *
  FROM movies
  WHERE imdb_rating > 8;
#+end_src

How does it work?

    1. The WHERE clause filters the result set to only include rows where the following /condition/ is true.

    2. ~imdb_rating > 8~ is the condition. Here, only rows with a value greater than 8 in the imdb_rating column will be returned.

The > is an /operator./ Operators create a condition that can be evaluated as either /true/ or /false./

Comparison operators used with the WHERE clause are:

    = equal to
    != not equal to
    > greater than
    < less than
    >= greater than or equal to
    <= less than or equal to

There are also some special operators that we will learn more about in the upcoming exercises.

*** Task 1
Suppose we want to take a peek at all the not-so-well-received movies in the database.

In the code editor, type:

#+begin_src
SELECT *
  FROM movies
  WHERE imdb_rating < 5;
#+end_src

*** Task 2
Now retrieve all the recent movies, specifically those that were released after 2014.

Select all the columns using *

#+begin_src
SELECT *
  FROM movies
  WHERE > 2014;
#+end_src

** Like 1
Like can be a useful operator when you want to compare similar values.

The movies table contains two films with similar titles, 'Se7en' and 'Seven'.

How could we select all movies that start with 'Se' and end with 'en' and have exactly one caracter in the middle?

#+begin_src
SELECT *
  FROM movies
  WHERE name LIKE 'Se_en';
#+end_src

    - LIKE is a special operator used with the WHERE clause to search for a specific pattern in a column.

    - ~name LIKE 'Se_ven'~ is a condition evaluating the name column for a specific pattern.

    - ~Se_en~ represents a pattern with a /wildcard/ character.

The _ means you can substitute any individual character here without breaking the pattern. The names Seven and Se7en both match this pattern.

** Like II
The percentage sign % is another wildcard character that can be used with LIKE.

This statement below filters the result set to only include movies wit names that begin with the letter 'A':

#+begin_src
SELECT *
  FROM movies
  WHERE name LIKE 'A%';
#+end_src

% is a wildcard character that matches zero or more missing characters in the pattern. For example:

    - A% matches all movies with names that begin with letter 'A'

    - %a matches all movies that end with 'a'

We can also use % both before and after a pattern:

#+begin_src
SELECT *
  FROM movies
  WHERE name LIKE '%man%';
#+end_src

Here, any movie that /contains/ the word 'man' in its name will be returned in the result.

LIKE is not case sensitive. 'Batman' and 'Man of Steel' will both appear in the result of the query above.

*** Task 1
Edit the query so that it selects all the information about the movie titles that begin with the word 'The'.

You might need a space in there!

** Is Null
By this point of the lesson, you might have noticed that there are a few missing values in the movies table. More often than not, the data you encounter will have missing values.

Unknown values are indicated by NULL.

It is not possible to test for NULL values with comparison operators, such as = and !=.

Instead, we will have to use these operators:

    - IS NULL

    - IS NOT NULL

To filter for all movies /with/ and IMDb rating:

#+begin_src
SELECT name
  FROM movies
  WHERE imdb_rating IS NOT NULL;
#+end_src

*** Task 1
Now let's do the opposite.

Write a query to find all the movies /without/ and IMDb rating.

Select only the name column!

#+begin_src
SELECT name
  FROM movies
  WHERE imdb_rating IS NULL;
#+end_src

** Between
The BETWEEN operator is used in a WHERE clause to filter the result set within a certain /range/. It accepts two values that are either numbers, text or dates.

For example, this statement filter the result set to only include movies with years from 1990 up to, /and including/ 1999.

#+begin_src
SELECT *
  FROM movies
  WHERE year BETWEEN 1990 AND 1999;
#+end_src

When the values are text, BETWEEN filters the result set for within the alphabetical range.

In this statement, BETWEEN filters the result set to only include movies with names that begin with the letter 'A' up to, /but not including ones that begin with 'J'./

However, if a movie has a name of simply ‘J’, it would actually match. This is because BETWEEN goes up to the second value — up to ‘J’. So the movie named ‘J’ would be included in the result set but not ‘Jaws’.

*** Task 1
Using the BETWEEN operator, write a query that selects all information about movies whose name begins with the letters ‘D’, ‘E’, and ‘F’.

#+begin_src
SELECT *
  FROM movies
  WHERE name BETWEEN 'D' AND 'G';
#+end_src

*Hint*
BETWEEN is case-sensitive. If the condition is BETWEEN 'a' AND 'z', it would only return lowercase (a-z) results and not uppercase (A-Z).

*** Task 2
Using the BETWEEN operator, write a new query that selects all information about movies that were released in the 1970's.

#+begin_src
SELECT *
  FROM movies
  WHERE year BETWEEN 1970 AND 1979;
#+end_src

** And
Sometimes we want to /combine multiple conditions/ in a WHERE clause to make the result set more specific and useful.

One way of doing this is to use the AND operator. Here, we use the AND operator to only return 90's romance movies.

#+begin_src
SELECT *
  FROM movies
  WHERE year BETWEEN 1990 AND 1999
  AND genre = 'romance';
#+end_src

    - year BETWEEN 1990 AND 1999 is the 1st condition.

    - genre = 'romance' is the 2nd condition.

    - AND combines the two conditions.

      [[./AND.svg]]

With AND, /both/ conditions must be true for the row to be included in the result.

*** Task 1
In the previous exercise, we retrieve every movie released in the 1970's.

Now, let's retrieve every movie released in the 70's that's also well received.

#+begin_src
SELECT *
  FROM movies
  WHERE year BETWEEN 1970 AND 1979
  AND imdb_rating > 8;
#+end_src

*** Task 2
Suppose we have a picky friend who only wants to watch old horror films.

Using AND, write a new query that selects all movies made prior to 1985 that are also in the horror genre.

#+begin_src
SELECT *
  FROM movies
  WHERE year < 1985
  AND genre = 'horror';
#+end_src

** Or
Similar to AND, the OR operator can also be used to combine multiple conditions in WHERE, but there is a fundamental difference:

    - AND operator displays a row if /all/ the conditions are true.

    - OR operator displays a row if /any/ condition is true.

Suppose we want to check out a new movie or something action-packed:

#+begin_src
SELECT *
  FROM movies
  WHERE year > 2014
  OR genre = 'action';
#+end_src

    - year > 2014 is the 1st condition

    - genre = 'action' is the 2nd condition

    - OR combines the two conditions

[[./OR.svg]]

With OR, if /any/ of the conditions are true, then the row is added to the result.

*** Task 1
Suppose we are in the mood for a good laugh or a good cry.

Using OR, write a query that returns all movies that are either a romance or a comedy.

#+begin_src
SELECT *
  FROM movies
  WHERE genre = 'romance'
  OR genre = 'comedy';
#+end_src

** Order By
It is often useful to list the data in our result set in a particular order.

We can /sort/ the results using ORDER BY, either alphabetically or numerically. Sorting the results often makes the data more useful and easier to analyze.

For example, if we want to sort everything by the movie's title from A through Z:

#+begin_src
SELECT *
  FROM movies
  ORDER BY name;
#+end_src

    - ORDER BY is a clause that indicates you want to sort the result set by a particular column.

    - name is the specified column.

Sometimes we want to sort things in a decreasing order. For example, if we want to select all of the well-received movies, sorted from highest to lowest by their year:

#+begin_src
SELECT *
  FROM movies
  WHERE imdb_rating > 8
  ORDER BY year DESC;
#+end_src

    - DESC is a keyword used in ORDER BY to sort the results in /descending order/ (high to low or Z-A).

    - ASC is a keyword used in ORDER BY to sort the results in /ascending/ order (low to high or A-Z).

The column that we ORDER BY doesn't even have to be one of the columns that we're displaying.

Note: ORDER BY always goes after WHERE (if WHERE is present).

*** Task 1
Suppose we want to retrieve the name and year columns of all the movies, ordered by their name alphabetically.

Type the following code:

#+begin_src
SELECT name, year
  FROM movies
  ORDER BY name;
#+end_src

*Hint*
We didn't add ASC here because ascending order is the default.

If you run this code, the result will start with ‘1408’, ‘3 Men and a Baby’ and then A-Z.

*** Task 2
#+begin_src
SELECT name, year, imdb_rating
  FROM movies
  ORDER BY imdb_rating DESC
#+end_src

Write a new query that retrieves the name, year, and imdb_rating columns of all the movies, ordered highest to lowest by their ratings.

** Limit
We've been working with a fairly small table (fewer than 250 rows), but most SQL tables contain hundreds of thousands of records. In those situations, it becomes important to cap the number of rows in the result.

#+begin_src
SELECT *
  FROM movies
  LIMIT 10;
#+end_src

LIMIT is a clause that lets you specify the maximun number of rows the result set will have. This saves space on our screen and makes our queries run faster.

Here, we specify that the result set can't haave more than 10 rows.

LIMIT always goes at the very end of the query. Also, it is not supported in all SQL databases.

*** Task 1
Combining your knowledge of LIMIT and ORDER BY, write a query that returns the top 3 highest rated movies.

Select all the columns.

#+begin_src
SELECT *
  FROM movies
  ORDER BY imbd_rating DESC
  LIMIT 3;
#+end_src

** Case
A CASE statement allows us to create different outputs (usually in the SELECT statement). It is SQL's way of handling ~if-then~ logic.

Suppose we want to condense the ratings in movies to three levels:

    - If the rating is above 8, then it is Fantastic.

    - If the rating is above 6, then it is Poorly Received.

    - Else, Avoid at All Costs.

      #+begin_src
      SELECT name,
        CASE
        WHEN imdb_rating > 8 THEN 'Fantastic'
        WHEN imdb_rating > 6 THEN 'Poorly Received'
        ELSE 'Avoid at All Costs'
        END
        FROM movies;
      #+end_src

    - Each WHEN tests a condition and the following THEN gives us the string if the condition is true.

    - The ELSE gives us the string if /all/ the above conditions are false.

    - The CASE statement must end with END.

In the result, you have to scroll right because the column name is very long. To shorten it, we can rename the column to 'Review' using AS:

#+begin_src
SELECT name,
 CASE
  WHEN imdb_rating > 8 THEN 'Fantastic'
  WHEN imdb_rating > 6 THEN 'Poorly Received'
  ELSE 'Avoid at All Costs'
 END AS 'Review'
FROM movies;
#+end_src

*** Task 1
Let’s try one on your own.

Select the name column and use a CASE statement to create the second column that is:

    ‘Chill’ if genre = 'romance'
    ‘Chill’ if genre = 'comedy'
    ‘Intense’ in all other cases

Optional: Rename the whole CASE statement to ‘Mood’ using AS.

Give it your best shot! Check hint for the answer.

#+begin_src
SELECT name
  CASE
  WHEN genre = 'romance' THEN 'Chill'
  WHEN genre = 'comedy' THEN 'Chill'
  ELSE 'Intense'
  END AS 'Mood'
  FROM movies;
#+end_src

** Review
We just learned how to query data from a database using SQL. We also learned how to filter queries to make the information more specific and useful.

Let’s summarize:

    - SELECT is the clause we use every time we want to query information from a database

    - AS renames a column or table

    - DISTINCT return unique values

    - WHERE is a popular command that lets you filter the results of the query based on conditions that you specify

    - LIKE and BETWEEN are especial operators

    - AND and OR combines multiple conditions

    - ORDER BY sorts the result

    - LIMIT specifies the maximum number of rows that the query will return

    - CASE creates different outputs

** Quiz

*** Question 1
What is the correct syntax to query both the name and date columns from the database?

#+begin_src
SELECT name, date
  FROM album;
#+end_src

*** Question 2
What is ORDER BY?

    - A clause that sorts the result set alphabetically or numerically

*** Question 3
What is LIMIT?

    - A clause that lets you specify the maximum number of rows the result set will have

*** Question 4
How would you query all the unique genres from the books table?

#+begin_src
SELECT DISTINC genres
  FROM books;
#+end_src

Correct! DISTINCT filters out all duplicate values in the genres column

*** Question 5
IS NULL condition returns true if the field has no value.

    - True

*** Question 6
Find the error in this code:

#+begin_src
SELECT name,
  CASE
  WHEN imdb_rating > 8 THEN 'Oscar'
  WHEN imdb_rating > 7 THEN 'Good'
  WHEN imdb_rating > 6 THEN 'Fair'
  END
  FROM movies;
#+end_src

    - Missing END statement

*** Question 7
What does the wildcard character % in the following SQL statement do?

#+begin_src
SELECT *
  FROM sports
  WHERE name LIKE '%ball';
#+end_src

    - It matches all sports that end with 'ball'.

*** Question 8
What code would you add to this query to place the colors in reverse alphabetical order (Z to A) by name?

#+begin_src
SELECT *
  FROM colors
  ORDER BY name DESC;
#+end_src

Correct! DESC sorts in a descending order (Z to A).

*** Question 9
Which operator would you use to query values that meet all conditions in a WHERE clause?

    - AND
      Correct! AND is used to /combine multiple conditions/ in a WHERE clause to make the result set more specific.

*** Question 10
What is LIKE?

    - A special operator that can be used with the WHERE clause to search for a pattern

*** Question 11
Which of the following is NOT a comparison operator in SQL?

    - Correct! Comparison operators are =, !=, >, <, >=, <=.

*** Question 12
What is the correct query to select only the cities with temperatures less than 35?

#+begin_src
SELECT *
  FROM cities
  WHERE temperature < 35;
#+end_src

* Agregate Functions
** Introduction
SQL Queries don't just access raw data, they can also perform calculations on the raw data to answer specific data questions.

Calculations performed on multiple rows of a table are called *aggregates*.

In this lesson, we have given you a table named ~fake_apps~ which is made up of fake mobile applications data.

Here is a quick preview of some important aggregates that we will cover in the next five exercises:

    - COUNT(): count the number of rows

    - SUM(): the sum of the values in a column

    - MAX() / MIN(): the largest/smallest value

    - AVG(): the average of the values in a column

    - ROUND(): round the values in the column

/Aggregate functions/ combine multiple rows together to form a single value of more meaningful information.

    - GROUP BY is a clause used with aggregate functions to combine data from one or more columns.

    - HAVING limit the results of a query based on an aggregate property.

** Count
The fastest way to calculate how many rows are in a table is to use the COUNT() function.

COUNT() is a function that takes the name of a columm as an argument and counts the number of non-empty values in that column.

#+begin_src
SELECT COUNT(*)
  FROM table_name;
#+end_src

Here, we want to count every row, so we pass * as an argument inside the parenthesis.

*** Task 1
Let's count how many apps are in the table.

#+begin_src
SELECT COUNT(*)
  FROM fake_apps;
#+end_src

*** Task 2
Add a WHERE clause in the previous query to count how many /free/ apps are in the table.

*Hint*
Remember the WHERE statement?

The following code should go inside the previous query, before the semicolon:

#+begin_src
SELECT COUNT(*)
FROM fake_apps
WHERE price = 0;
#+end_src

    - WHERE indicates we want to only include rows where the following condition is true.

    - price = 0 is the condition.

** Sum
SQL makes it easy to add all values in a particular column using SUM().

SUM() is a function that takes the name of a column as an argument and returns the sum of all the values in that column.

What is total number of downloads for all the apps combined?

#+begin_src
SELECT SUM(downloads)
  FROM fake_apps;
#+end_src

This adds all values in the ~downloads~ column.

** Max / Min
The MAX() and MIN() functions return the highest and lowest values is a column respectively.

How many downloads does the most popular app have?

#+begin_src
SELECT MAX(downloads)
  FROM fake_apps;
#+end_src

The most popular app has 31090 downloads!

MAX() takes the name of a column as an argument and returns the largest value in that column. Here, we returned the largest value in the downloads column.

MIN() works the same way but it does the exact opposite; it returns the smallest value.

*** Task 1
What is the least number of times an app has been downloaded?

#+begin_src
SELECT MIN(downloads)
  FROM fake_apps;
#+end_src

*** Task 2
Write a new query that returns the price of the most expensive app.

#+begin_src
SELECT MAX(price)
  FROM fake_apps;
#+end_src

** Average
SQL uses  the AVG() function to quickly calculate the average value of a particular column.

The statement below returns the average number of downloads for an app in our database:

#+begin_src
SELECT AVG(downloads)
  FROM fake_apps;
#+end_src

The AVG() function works by taking a column name as an argument and returns the average value for that column.

** Round
By default, SQL tries to be as precise as possible without rounding. We can make the result table easier to read using the ROUND() function.

ROUND() function takes two arguments inside the parenthesis:

    1. a column name

    2. an integer

It rounds the values in te column to the number of decimal places specified by the integer.

#+begin_src
SELECT ROUND(price, 0)
  FROM fake_apps;
#+end_src

Here, we pass the column price and integer 0 as arguments. SQL rounds the values in the column to 0 decimal places in the output.

*** Task 1
Let's return the name column and a rounded price column.

#+begin_src
SELECT name, ROUND (price, 0)
  FROM fake_apps;
#+end_src

*Hint*
We are selecting ROUND (price, 0) as the second column in this query.

*** Task 2
In the last exercise, we were able to get the average price of an app ($2.02365) using this query:

#+begin_src
SELECT AVG(price)
  FROM fake_apps;
#+end_src

Now, let's edit this query so that it rounds this result to 2 decimal palces.

#+begin_src
SELECT ROUND(AVG(price), 2)
  FROM fake_apps;
#+end_src

*Hint*
You can treat AVG(price) just like any other value and place it inside the ROUND function like so:

ROUND(AVG(price), 2)

Here, AVG(price) is the 1st argument and 2 is the 2nd argument because we want to round it to two decimal places:

SELECT ROUND(AVG(price), 2)
FROM fake_apps;

** Group By I
Oftentimes, we will want to calculate an aggregate for data with certain characteristics.

For instance, we might want to know the mean IMDb ratings for all movies each year. We could calculate each number by a series of queries with different WHERE statements, like so:

#+begin_src
SELECT AVG (imdb_rating)
  FROM movies
  WHERE year = 1999;

SELECT AVG(imdb_rating)
  FROM movies
  WHERE year = 2000;

SELECT AVG(imdb_rating)
  FROM movies
  WHERE year = 2001;
#+end_src

and so on.

We can use GROUP BY to do this in a single step:

#+begin_src
SELECT year, AVG(imdb_rating)
  FROM movies
  GROUP BY year
  ORDER BY year;
#+end_src

GROUP BY is a clause in SQL that is used with aggregate functions. It is used in collaboration with the SELECT statement to arrange identical data into /groups/.

The GROUP BY statement comes after any WHERE statements, but before ORDER BY or LIMIT.

*** Task 1
In the code editor, type:

#+begin_src
SELECT price, COUNT(*)
  FROM fake_apps
  GROUP BY price;
#+end_src

Here, our aggregate function is COUNT()  and we arranged price into groups.

What do you expect the result to be?

*Hint*
The result contains the total number of apps for each price.

It is organized into two columns, making it very easy to see the number of apps at each price.

*** Task 2
In the previous query ,  add a WHERE clause to count the total number of apps that have been downloaded more than 20,000 times, at each price.

*Hint*
Remember, WHERE statement goes /before/ the GROUP BY statement:

#+begin_src
SELECT price, COUNT(*)
  FROM fake_apps
  WHERE downloads > 20000
  GROUP BY price;
#+end_src

*** Task 3
Write a new query that calculates the total number of downloads for each category.

#+begin_src
SELECT category, SUM(downloads)
  FROM fake_apps
  GROUP BY category;
#+end_src

** Group By II
Sometimes, we want to GROUP BY calculation done on a column.

For instance, we might want to know how many movies have IMDb ratings that round to 1, 2, 3, 4, 5. We could do this  using the following syntax:

#+begin_src
SELECT ROUND(imdb_rating),
  COUNT(name)
  FROM movies
  GROUP BY ROUND(imdb_rating)
  ORDER BY ROUND(imdb_rating);
#+end_src

However, this query may be time-consuming to write and more prone to error.

SQL lets us use column reference(s) in our GROUP BY that will make our lives easier.

    - 1 is the first column selected

    - 2 is the second column selected

    - 3 is the third column selected

and so on.

The following query is equivalent to the one above:

#+begin_src
SELECT ROUND(imdb_rating),
  COUNT(name)
  FROM movies
  GROUP BY 1
  ORDER BY 1;
#+end_src

*** Task 1
Suppose we have the query below:

#+begin_src
SELECT category,
  price,
  AVG(downloads)
FROM fake_apps
GROUP BY category, price;
#+end_src

Write the exact query, but use column reference numbers instead of column names after GROUP BY.

#+begin_src
SELECT category,
  price,
  AVG(downloads)
FROM fake_apps
GROUP BY 1, 2;
#+end_src

** Having
In addition to being able to group data using GROUP BY, SQL also allows you to filter which groups to include and which to exclude.

For instance, imagine that we want to see how many movies of different genres were produced each year, but we only care about years and genres with al least 10 movies.

We can't use WHERE here because we don't want to filter the rows; we want to /filter groups./

This is where HAVING comes in.

HAVING is very similar to WHERE. In fact, all types of WHERE clauses you learned about thus far can be used with HAVING.

We can use the following for the problem:

#+begin_src
SELECT year,
  genre,
  COUNT(name)
FROM movies
GROUP BY 1, 2
HAVING COUNT(name) > 10;
#+end_src

    - When we want to limit the results of a query based on values of the individual rows, use WHERE.

    - When we want to limit the results of a query based on an aggregate property, use HAVING.

HAVING statement always comes after GROUP BY, but before ORDER BY and LIMIT.

*** Task 1
Suppose we have the query below:

#+begin_src
SELECT price,
  ROUND(AVG(downloads)),
  COUNT(*)
FROM fake_apps
GROUP BY price;
#+end_src

It returns the average downloads (rounded) and the number of apps -at each price point.

However, certain price points don't have very many apps, so their average dowloads are less meaningful.

Add a HAVING clause to restrict the query to price points that have more than 10 apps.

#+begin_src
SELECT price,
  ROUND(AVG(downloads)),
  COUNT(*)
FROM fake_apps
GROUP BY price
HAVING COUNT(*) > 30;
#+end_src

** Review
You just learned how to use aggregate functions to perform calculations on your data. What can we generalize so far?

    - COUNT(): count the number of rows

    - SUM(): the sum of the values in a column

    - MAX / MIN: the largest/smallest value

    - AVG(): the average of the values in a column

    - ROUND(): round the values in the column

/Agreggate functions/ combine multiple rows together to form a single value of more meaningful information.

    - GROUP BY is a clause used with aggregate functions to combine data from one or more columns.

    - HAVING limit the results of a query based on an aggregate property.

* Multiple Tables
** Introduction
In order to efficiently store data, we often spread related information across multiple tables.

For instance, imagine that we're running a magazine company where users can have different types of subscriptions to different products. Different subscriptions might have many different properties. Each customer would also have lots of associated information.

We could have one table with all of the following information:

    - ~order_id~

    - ~customer_id~

    - ~customer_name~

    - ~customer_address~

    - ~subscription_id~

    - ~subscription_description~

    - ~subscription_monthly_price~

    - ~subscription_length~

    - ~purchase_date~

However, a lot of this information would be repeated. If the same customer has multiple subscriptions, that customer's name and address will be reported multiple times. If the same subscription type is ordered by multiple customers, then the subscription price and subscription description will be repeated. This will make our table big and unmanageable.

So instead, we can split our data into three tables:

    1. ~orders~ would contain just the information necessary to describe what was ordered:

           - ~order_id~, ~customer_id~, ~subscription_id~, ~purchase_date~.

    2. ~subscriptions~ would contain the information to describe each type of subscription:

           - ~subscription_id~, ~description~, ~price_per_month~, ~subscription_length~

    3. customers would contain the information for each customer:

           - ~customer_id~, ~customer_name~, ~address~

In this lesson, we'll learn the SQL commands that will help us work with data that is stored in multiple tables.

*** Task 1
Examine these tables by pasting the following code into the editor:

#+begin_src
SELECT *
  FROM orders
  LIMIT 5;

SELECT *
  FROM subscriptions
  LIMIT 5;

SELECT *
  FROM customers
  LIMIT 5;
#+end_src

** Combining tables manually
Let's return to our magazine company. Suppose we have the three tables described in the previous exercise -shown in the browser on the right:

    - orders

    - subscriptions

    - customers

If we just look at the orders table, we can't really tell what's happened in each order. However, if we refer to the other tables, we can get a complete picture.

Let's examine the order with an ~order_id~ of 2. It was purchased by the customer with a ~customer_id~ of 2.

To find out the customer's name, we look at the customers table and look for the item with a ~customer_id~ value of 2. We can see that Customer 2's name is 'Jane Doe' and that she lives at '456 Park Ave'.

Doing this kind of matching is called *joining* two tables.

*** Task 1
Using the tables displayed, what is the description of the magazine ordered in ~order_id~ 1?

** Combining tables with SQL
Combining tables manually is time-consuming. Luckily, SQL gives us an easy sequence for this: it's called a JOIN.

If we want to combine orders and customers, we would type:

#+begin_src
SELECT *
  FROM orders
  JOIN customers
  ON orders.customer_id
  = customers.customer_id;
#+end_src

Let's break down this command:

1. The first line selects all columns from our combined table. If we only want to select certain columns, we can specify which ones we want.

2. The second line specifies the first table taht we want to look in, orders

3. The third line uses JOIN to say that we want to combine information from orders with customers

4. The fourth line tells us how to combine the two tables. We want to match orders table's ~customer_id~ column with customers table's ~customer_id~ column.

Because column names are often repeated across multiple tables, we use the syntax ~table_name.colum_name~ to be sure that our request for columns are unanbiguous. In our example, we use this syntax in the ON statement, but we will also use it in the SELECT or any other statement where we refer to column names.

*** Task 1
Join orders table and subscriptions table and select all columns.

Make sure to join on the subscriptions_id column.

#+begin_src
SELECT *
  FROM orders
  JOIN subscriptions
  ON orders.subscription_id =
  subscriptions.subscription_id;

SELECT *
  FROM orders
  JOIN subscriptions
  ON orders.subscription_id =
  suscriptions.subscription_id
  WHERE subcriptions.description = 'Fashion Magazine';
#+end_src

** Inner Joins
Let's revisit how we joined orders and customers. For every possible value of customers_id in orders, there was a corresponding row of customers with the same customer_id.

What if that wasn't true?

For instance, imagine that our customers table was out of date, and was missing any information on customer 11. If that customer had an order in orders, what would happen when we joined the tables?

When we perform a simple JOIN (often called an /inner join/) our result only includes rows that match our ON condition.

Consider the following animation, which illustrates an inner join of two tables on table1.c2 = table2.c2:

[[./inner-join.webp]]

The first and last rows have matching values of c2. The middle rows do not match. The final result has all values from the first and last rows but does not include the non-matching middle row.

*** Task 1
Suppose we are working for The Codecademy Times, a newspaper with two types of subscriptions:

    - print newspaper

    - online articles

Some users subscribe to just the newspaper, some subscribe to just the online edition, and some subscribe to both.

There is a newspaper table that contains information about the newspaper subscribers.

Count the number of subscribers who get a print newspaper using COUNT().

*** Task 2
There is also an online table taht contains information about the online subscribers.

Count the number of subscribers who get an online newspaper using COUNT().

*** Task 3
Join newspaper table and online table on their id columns (the unique ID of the subscriber).

#+begin_src

-- Use COUNT to count all the rows of a table

SELECT COUNT(*)
  FROM newspaper;

SELECT COUNT(*)
  FROM online;

-- JOIN newspaper an online table ON id

SELECT COUNT(*)
  FROM newspaper
  JOIN online
  ON newspaper.id = online.id;

#+end_src

** Left Joins
What if we want to combine two tables and keep some of the un-matched rows?

SQL let us do this through a command called LEFT JOIN. A /left join/ will keep all rows from the first table, regardless of whether there is a matching row in the second table.

Consider the following animation:

[[./left-join.webp]]

The first and last rows have matching values of c2. The middle rows do not match. The final result will keep all rows of the first table but will onit the un-matched row from the second table.

This animation represents a table operation produced by the following command:

#+begin_src
SELECT *
  FROM table1
  LEFT JOIN table2
  ON table1.c2 = table2.c2;
#+end_src

    1. The first line selects all columns from both tables.

    2. The second line selects table1 (the left table)

    3. The third line performs a LEFT JOIN on table2 (the right rable).

    4. The fourth line tells SQL how to perform the join (by looking for matching values in column c2).

*** Task 1
Let's return to our newspaper and online subscribers.

Suppose we want to know how many users subscribe to the print newspaper, but no to the online.

Start by performing a left join of newspaper table and online table on their id columns and selecting all columns.

#+begin_src
SELECT *
  FROM newspaper
  LEFT JOIN online
  ON newspaper.id = online.id;
#+end_src

*** Task 2
In order to find which users do /not/ subscribe to the online edition, we need to add a WHERE clause.

Add a second query after your first one that adds the following WHERE clause and condition:

#+begin_src
SELECT *
  FROM newspaper
  LEFT JOIN online
  ON newspaper.id = online.id
  WHERE online.id IS NULL;
#+end_src

This will select rows where there was no corresponding row from th online table.

** Primary key vs foreing key
Let's return to our example of the magazine subscriptions. Recall that we had three tables: orders, subscriptions, and customers.

Each of these tables has a column that uniquely identifies each row of that table:

    - ~order_id~ for orders

    - ~subscription_id~ for subscriptions

    - ~customer_id~ for customers

These special columns are called *primary keys*.

Primary keys have a few requirements:

    - None of the values can be NULL.

    - Each value must be unique (i.e., you can't have two customers with the same ~customer_id~ in the customers table).

    - A table can not have more than one primary key column.

Note that ~customer_id~ (the primary key for customers) and ~subscription_id~ (the primary key for subscriptions) both appear in this.

When the primary key for one table appears in a different table, it is called a *foreign key*.

So ~customer_id~ is a primary key when it appears in customers, but a foreign key when it appears in orders.

In this example, our primary keys all had somewhat descriptive names. Generally, the primary key will just be called ~id~. Foreign keys will have more descriptive names.

Why is this important? The most common types of joins will be joining a foreign key form one table with the primary key from another table. For instance, when we join orders and customers, we join on ~customers_id~, which is a foreign key in orders and the primary key in customers.

*** Task 1
Suppose Columbia University has two tables in their database:

    - The classes table contains information on the classes that the school offers. Its primary key is id.

    - The students table contains information on all students in the school. Its primary key is id. It contains the foreign key ~class_id~, which corresponds to the primary key of classes.

Perform an inner join of classes and students using the primary and foreign keys described above, and select all the columns.

#+begin_src
SELECT *
  FROM classes
  JOIN students
  ON classes.id = students.class_id;
#+end_src

** Cross Join
So far, we've focused on matching rows that have some information in common.

Sometimes, we just want to combine all rows of one table with all rows of another table.

For instance, if we had a table of shirts and a table of pants, we might want to know all the possible combinations to create different outfits.

Our code might look like this:

#+begin_src
SELECT shirts.shirt_color,
  pants.pants_color
  FROM shirts
  CROSS JOIN pants;
#+end_src

    - The first two lines select the columns shirt_color and pants_color.

    - The third line pulls data from the table shirts.

    - The fourth line performs a CROSS JOIN with pants.

Notice that cross joins don't require an ON statement. You are not really joining on any columns!

If we have 3 different shirts (white, grey, and olive) and 2 different pants (light denim and black), the results might look like this:

shirt_color 	pants_color
white 	        light denim
white 	        black
grey 	                light denim
grey 	                black
olive 	        light denim
olive 	        black

3 shirts x 2 pants = 6 combinations!

This clothing example is fun, but it's not very practically useful.

A more common usage of CROSS JOIN  is when we need to compare each row of a table to a list of values.

Let's return to our newspaper subscriptions. This table contains two columns that we haven't discussed yet:

    - ~start_mont~: the first month where the customer subscribed to the print newspaper (i.e., 2 for February)

    - ~end_month~: the final month where the customer subscribed to the print newspaper

Suppose we wanted to know how many users were subscribed during each month of the year. For each month (1, 2, 3) we would need to know if a user was subscribed. Follow the steps below to see how we can use a CROSS JOIN to solve this problem.

*** Task 1
Eventually, we'll use a cross join to help us, but first, let's try a simpler problem.

Let's start by counting the number of customers who were subscribed to the newspaper during March.

Use COUNT(*) to count the number of rows and a WHERE clause to restrict to two conditions:

    - start_month <= 3

    - end_month >= 3

*** Task 2
The previous query lets us investigate one month at a time. In order to check across all months, we're going to need to use a cross join.

Our database contains another table called months which contains tha numbers between 1 and 12.

Select all columns from the cross join of newspapers and months.

*** Task 3
Create a third query where you add a WHERE statement to your cross join to restrict to two conditions:

    - ~start_month <= month~

    - ~end_month >= month~

This will select all months where a user was subscribed.

*** Task 4
Create a final query where you aggregate over each month to count the number of subscribers.


      #+begin_src
      -- Customers subscribed during March

      SELECT COUNT(*)
        FROM newspaper
        WHERE start_month <= 3
        AND end_month >= 3;

      -- Select all columns from the cross join fo newspaper and months

      SELECT *
      FROM newspaper
      CROSS JOIN months;

      -- Create a third query where you add a WHERE statement to your CROSS JOIN to restrict to two conditions

      SELECT *
        FROM newspaper
        CROSS JOIN months
        WHERE start_month <= month
        AND end_month >= month
        GROUP BY month;

      #+end_src

** Union
Sometimes we just want to stack one dataset on top of the other. Well, the UNION operator allows us to do that.

Suppose we have two tables and they have the same columns.

If we combine these two with UNION:

#+begin_src
SELECT *
  FROM table1
  UNION
SELECT *
  FROM table2;
#+end_src

SQL has strict rules for appending data:

    - Tables must have the same number of columns.

    - The columns must have the same data types in the same order as the first table.

*** Task 1
Let's return to our newspaper and online subscriptions. We'd like to create one big table with both sets of data.

Use UNION to stack the newspaper table on top of the online table.

#+begin_src
SELECT *
  FROM newspaper
  UNION
SELECT *
  FROM online;
#+end_src

** With
Often times, we want to combine two tables, but one of the tables is the result of another calculation.

Let's return to our magazine order example. Our marketing department might want to know a bit more about our customers. For instance, they might want to know how many magazines each customer subscribes to. We can easily calculate this using our orders table:

#+begin_src
SELECT customer_id,
  COUNT(subscription_id) AS
  'subscriptions'
  FROM orders
  GROUP BY customer_id;
#+end_src

This query is good, but a ~customer_id~ isn't terribly useful for our marketing department, they probably want to know the customer's name.

We want to be able to join the results of this query with our customers table, which will tell us the name of each customer. We can do this by using a WITH clause.

    - The WITH statement allows us to perform a separate query (such as aggregating customer's subscriptions)

    - ~previous_results~ is the alias that we will use to reference any columns from the query inside of the WITH clause.

    - We can then go on to do whatever we want with this temporary table (such as join the temporary table with another table)

Essentially, we are putting a whole first query inside the parentheses () and giving it a name. After that, we can use this name as if it's a table a write a new query /using/ the first query.

#+begin_src
SELECT customer_id,
  COUNT(subscription_id) AS 'subscriptions'
  FROM orders
  GROUP BY customer_id;

WITH previous_query AS (
  SELECT customer_id;
  COUNT(subscription_id) AS 'subscriptions'
  FROM orders
  GROUP BY customer_id
  )

  SELECT customers.customer_name,
  previous_query.subscriptions
  FROM previous_query
  JOIN customers
  ON previous_query.customer_id = customers.customer_id;
#+end_src

** Review
In this lesson, we learned about relationships between tables in relational databases and how to query information from multiple tables using SQL.

Let's summarize what we've learned so far:

    - JOIN will combine rows from different tables if the join condition is true.

    - LEFT JOIN will return every row in the left table, and if the join condition is not met, NULL values are used to fill in the columns from the right table.

    - Primary key is a column that serves a unique identifier for the rows in the table.

    - Foreign key is a column that contains the primary key to another table.

    - CROSS JOIN lets us combine all rows of one table with all rows of another table.

    - UNION stacks one dataset on top of another.

    - WITH allows us to define one or more temporary tables that can be used in the final query.

* Aggregate Functions Challenge
** Code Challenge 1
The users table has the following columns:

    - id

    - first_name

    - last_name

    - email

    - password

[[./users_table.png]]

*** Task 1
Use COUNT() and a LIKE operator to determine the number of users that have an email ending in '.com'.

#+begin_src
SELECT COUNT(*)
FROM users
WHERE email LIKE '.com';
#+end_src

** Code Challenge 2

*** Task 1
What are the most popular first names on Codeflix?

Use COUNT(), GROUP BY, and ORDER BY to create a list of first names and occurrences within the users table.

#+begin_src
  SELECT first_name, COUNT(*) AS 'count'
  FROM users
  GROUP BY first_name
  ORDER BY COUNT(*) DESC;
#+end_src

** Code Challenge 3
The ~watch_history~ table has the following columns:

    - ~id~

    - ~user_id~

    - ~watch_date~

    - ~watch_duration_in_minutes~

      [[./users_table.png]]

*** Task 1
The UX Research Team wants to see a distribution of watch durations. They want the result to contain:

    - ~duration~, which is the watch event duration, rounded to the closest minute

    - ~count~, the number of watch events falling into this "bucket"

Use ~COUNT()~, ~GROUP BY~, and ~ORDER BY~ to create this result and order this data by increasing ~duration~.

#+begin_src
 SELECT ROUND(watch_duration_in_minutes, 0) AS duration,
  COUNT(*) AS 'count'
  FROM watch_history
  GROUP BY duration
  ORDER BY duration ASC;
#+end_src

*Hint*
Use ROUND() to create a column which is the watch duration rounded to the nearest minute. And return a second column that has the number of watch events falling into each duration.

** Code Challenge 4
The ~payments~ table has the following columns:

    - ~id~

    - ~user_id~

    - ~amount~

    - ~status~

    - ~pay_date~

*** Task 1
Find all the users that have successfully made a payment to Codeflix and find their total amount paid.

Sort them by their total payments (from high to low).

Use SUM(), WHERE, GROUP BY, and ORDER BY.

*Hint*

Group the users and calculate their total payments by using SUM().

Filter the successful payments by using WHERE with the condition status = 'paid'.

Sort the total payments in a descending order using ORDER BY and DESC.

#+begin_src
  SELECT user_id, SUM(amount)
  FROM payments
  WHERE status = 'paid'
  GROUP BY user_id
  ORDER BY SUM(amount) DESC;
#+end_src

You can also rename the SUM(amount) column:

#+begin_src
  SELECT user_id, SUM(amount) AS 'total'
  FROM payments
  WHERE status = 'paid'
  GROUP BY user_id
  ORDER BY total DESC;
#+end_src

And add column reference numbers:

#+begin_src
  SELECT user_id, SUM(amount) AS 'total'
  FROM payments
  WHERE statuts = 'paid'
  GROUP BY 1
  ORDER BY 2 DESC;
#+end_src

** Code Challenge 5

*** Task 1
Generate a table of user ids and total watch duration for users who watched more than 400 minutes of content.

Use SUM(), GROUP BY, and HAVING to achieve this.

*Hint*
Use SUM() and GROUP BY to calculate a total amount for each ~user_id~.

#+begin_src
  SELECT user_id,
  SUM(watch_duration_in_minutes)
  FROM watch_history
  GROUP BY user_id
  HAVING
  SUM(watch_duration_in_minutes) > 400;
#+end_src

If you give the total amount an alias, you can use it in HAVING:

#+begin_src
  SELECT user_id,
  SUM(watch_duration_in_minutes) AS 'total_duration'
  FROM watch_history
  GROUP BY 1
  HAVING total_duration > 400;
#+end_src

** Code Challenge 6

*** Task 1
To the nearest minute, how many minutes of content were streamed on Codeflix?

Use the SUM() and ROUND() functions with the watch_history table.

Treat ~SUM(watch_duration_in_minutes)~ just like any other value and place it inside the ROUND() function like so:

#+begin_src
  SELECT ROUND(SUM(watch_duration_in_minutes), 0)
  FROM watch_history;
#+end_src

Here, SUM(watch_duration_in_minutes) is the 1st argument and 0 is the 2nd argument because we want to round it to zero decimal places.

** Code Challenge 7
The payments table has the following columns:

    - ~id~

    - ~user_id~

    - ~amount~

    - ~status~

    - ~pay_date~

*** Task 1
Which days in this period did Codeflix collect the most money?

Your result should have two columns, ~pay_date~ and total ~amount~, sorted by the latter descending.

This should only include successful payments (status = 'paid').

Use SUM(), GROUP BY, and ORDER BY.

#+begin_src
  SELECT pay_date, SUM(amount)
  FROM payments
  WHERE status = 'paid'
  GROUP BY pay_date
  ORDER BY SUM(amount) DESC;
#+end_src

You can also rename ~pay_date~ → day and ~SUM(amount)~ → total using AS:

#+begin_src
  SELECT pay_date AS 'day',
  SUM(amount) AS 'total'
  FROM payments
  WHERE status = 'paid'
  GROUP BY day
  ORDER BY total DESC;
#+end_src

** Code Challenge 8

*** Task 1
When users successfully pay Codeflix (status=''paid"), what is the average payment amount?

#+begin_src
  SELECT AVG(amount)
  FROM payments
  WHERE status = 'paid';
#+end_src

** Code Challenge 9

*** Task 1
Of all the events in the watch_history table, what is the duration of the longest individual watch event? What is the duration of the shortest?

Use one query and rename the results to max and min.

#+begin_src
  SELECT MAX(watch_duration_in_minutes), MIN(watch_duration_in_minutes)
  FROM watch_history;
#+end_src

* The Metropolitan Museum of Art
The Metropolitan Museum of Art of New York is one of the world's largest and finest art museums.

In this project, you will be working with a table named met that contains the museum's collection of American Decorative Arts.

It has the following columns:

    - ~id~ - the id of the art piece

    - ~department~ - the department of the art piece

    - ~category~ - the category of the art piece

    - ~title~ - the title name of the art piece

    - ~artist~ - the name of the artist

    - ~date~ - the date(s) of the art piece

    - ~medium~ - the medium of the art piece

    - ~country~ - the country of the artist

 This data was kindly made publicly available under the Open Access Policy.

** Pre-Gaming for Aggregates

*** Task 1
Start by getting a feel for the met table:

#+begin_src
  SELECT *
  FROM met
  LIMIT 10;
#+end_src

What are the column names?

*** Task 2
How many pieces are in the American Decorative Art collection?

#+begin_src
  SELECT COUNT(*)
  FROM met;
#+end_src

*** Task 3
Celery was considered a luxurious snack in the Victorian era (around the 1800s). Wealthy families served stalks of it in intricate glass vases.

Don't believed it? Count the number of pieces where the ~category~ includes 'celery'.

#+begin_src
  SELECT COUNT(*)
  FROM met
  WHERE category
  LIKE '%celery%';
#+end_src

#+begin_src
  SELECT DISTINCT category
  FROM met
  WHERE category LIKE '%celery%';
#+end_src

*** Task 4
Find the title and medium of the oldest piece(s) in the collection.

First, let's find the "lowest" year:

#+begin_src
  SELECT MIN(date)
  FROM met;
#+end_src

The result is 1600-1700.

Now, let's try this:

#+begin_src
  SELECT date, title, medium
  FROM met
  WHERE date LIKE '%1600%';
#+end_src

Woah! Betty Lamp, Candlestick, and Casement Window are among the oldest pieces in the collection.

*** Task 5
Not every American decoration is from the Americas... where are they are coming from?

Find the top 10 countries with the most pieces in the collection.

#+begin_src
  SELECT country, COUNT(*)
  FROM met
  GROUP BY country
  ORDER BY COUNT(*) DESC
  LIMIT 10;
#+end_src

You can also use column reference numbers and remove NULL values:

#+begin_src
  SELECT country, COUNT(*)
  FROM met
  WHERE country IS NOT NULL
  GROUP BY 1
  ORDER BY 2 DESC
  LIMIT 10;
#+end_src

*** Task 6
There are all kinds of American decorative art in the Met's collection.

Find the categories HAVING more than 100 pieces.

#+begin_src
  SELECT category, COUNT(*)
  FROM met
  GROUP BY category
  HAVING COUNT(*) > 100;
#+end_src

*** Task 7
Lastly, let’s look at some bling!

Count the number of pieces where the medium contains ‘gold’ or ‘silver’.

And sort in descending order.

#+begin_src
  SELECT medium, COUNT(*)
  FROM met
  WHERE medium LIKE '%gold%'
  OR medium LIKE '%silver%'
  GROUP BY 1
  ORDER BY 2 DESC;
#+end_src

#+begin_src
  SELECT CASE
   WHEN medium LIKE '%gold%'   THEN 'Gold'
   WHEN medium LIKE '%silver%' THEN 'Silver'
   ELSE NULL
  END AS 'Bling',
  COUNT(*)
  FROM met
  WHERE Bling IS NOT NULL
  GROUP BY 1
  ORDER BY 2 DESC;
#+end_src

* Cryptocurrency Exchange
Fiddy Cent is a digital currency exchange headquartered in Neo Tokyo. They broker exchanges of Bitcoin, Bitcoin Cash, Ethereum, and Litecoin with fiat currencies in around 50 countries.

Help them analyze their January ledger data using SQL aggregate functions! You are given the transactions table, which contains both money-in and money-out transactions.

** Write the following queries:

*** Task 1
Let's start by checking out the whole transactions table:

#+begin_src
  SELECT *
  FROM transactions;
#+end_src

What are the column names?

*** Task 2
The ~money_in~ column records the amount (in USD) the user bought.

What is the total ~money_in~ in the table?

#+begin_src
  SELECT SUM(money_in)
  FROM transactions;
#+end_src

*** Task 3
The ~money_out~ column records the amount (in USD) the user sold.

What is the total ~money_out~ in the table?

#+begin_src
  SELECT SUM(money_out)
  FROM transactions;
#+end_src

*** Task 4
It was reported that Bitcoin dominates Fiddy Cent's exchange. Let's see if it is true within these dates by answering two questions:

    - How many ~money_in~ transactions are in this table?

    - How many ~money_in~ transactions are in this table where 'BIT' is the ~currency~?

#+begin_src
SELECT COUNT(money_in)
  FROM transactions

SELECT COUNT(money_in)
  FROM transactions
  WHERE currency = 'BIT';
#+end_src

*** Task 5
What was the largest transaction in this whole table?

Was it ~money_in~ or ~money_out~?

#+begin_src
  SELECT MAX(money_in)
  FROM transactions;

  SELECT MAX(money_out)
  FROM transactions;
#+end_src

*** Task 6
What is the average money_in in the table for the currency ethereum ('ETH')?

#+begin_src
  SELECT AVG(money_in)
  FROM transactions
  WHERE currency = 'ETH';
#+end_src

*** Task 7
Let's build a ledger for the different dates.

Select date, average ~money_in~, and average ~money_out~ from the table.

And group everything by ~date~.

#+begin_src
  SELECT date, AVG(money_in), AVG(money_out)
  FROM transactions
  GROUP BY date;
#+end_src

*** Task 8
To make the previous query easier to read, round the averages to 2 decimal places.

Give the column aliases using AS for readability.

#+begin_src
  SELECT date AS 'Date',
  ROUND(AVG(money_in), 2) AS 'Average Buy',
  ROUND(AVG(money_out), 2) AS 'Average Sell',
  FROM transactions
  GROUP BY date;
#+end_src

* Multiple Tables Challenge

** Songify Introduction
In this code challenge, you'll be performing analysis for Songify, a fictional music streaming service. Songify has a "freemium" model, meaning that it offers both a free product and a premium paid product.

You'll be working with six tables:

    - plans

    - users

    - premium_users

    - songs

    - months

    - plays

[[./SQL_diagram_v6.pdf]]

** Code Challenge 1
For this challenge, you'll use the following tables:

~plans~

| *Column*      | *Description*                      |
| id          | A unique identifier for the plan |
| price       | The monthly cost of the plan     |
| description | A description of the plan        |

~premiun_users~

| *Column*             | *Description*                                            |
| user_id            | A unique identifier for the user                       |
| membership_plan_id | An ID for the user's payment plan (matches `plans.id`) |
| purchase_date      | Date when the user purchased their premium plan        |
| cancel_date        | Date when the user canceled (NULL if they haven't)     |

*** Task 1
Let's see which plans are used by which premium members!

The column ~membership_plan_id~ in premium users should match the column ~id~ in plans.

Join ~plans~ and ~premiun_users~ and select:

    - ~user_id~ from ~premiun_users~

    - ~description~ from ~plans~

Be sure to select the columns in this order

#+begin_src
  SELECT premium_users.user_id, plans.description
  FROM premium_users
  JOIN plans
  ON plans.id = premium_users.membership_plan_id;
#+end_src

** Code Challenge 2
For this exercise, you will use the following tables:

~songs~

| *Column* | *Description*                       |
| id     | A unique identifier for each song   |
| title  | The title of the song               |
| artist | The artist who recorded the song    |
| year   | The year that the song was released |

~plays~

| Column    | Description                       |
| user_id   | A unique identifier for each user |
| song_id   | An id for which song  was played  |
| play_date | The date the user played the song |
| play_hour | The hour the user played the song |

*** Task 1
Let's see the titles of songs that were played by each user!

The column ~song_id~ in plays should match the column ~id~ in songs.

Join plays to songs and select:

    - ~user_id~ from plays

    - ~play_date~ from plays

    - ~title~ from songs

(Be sure to select the columns in this order)

#+begin_src
SELECT plays.user_id,
       plays.play_date,
       songs.title
  FROM plays
  JOIN songs
  ON plays.song_id = songs.id;
#+end_src

** Code Challenge 3
For this challenge, you'll use the following tables:

~users~

| *Column*    | *Description*                       |
| id        | A unique identifier for each user |
| firs_name | The first name of the user        |
| last_name | The last name of the user         |
| age       | The age name of the user          |
| gender    | The gender name of the user       |

~premium_users~

| *Column*             | *Description*                       |
| user_id            | A unique identifier for each user |
| membership_plan_id | Id for user's pay plan            |
| purchase_date      | Date user purchase premium        |
| cancel_date        | Date user canceled                |

*** Task 1
Which users aren't premium users?

Use a LEFT JOIN to combine ~users~ and ~premium_users~ and select ~id~ from users.

A /left join/ will keep all rows from the first table, regardless of whether there is a matching row in the second table.

#+begin_src
  SELECT users.id
  FROM users
  LEFT JOIN premium_users
  ON users.id = premium_users.user_id
  WHERE premium_users.user_id IS NULL;
#+end_src

** Code Challenge 4
We've used a WITH statement to create two temporary tables:

    - ~january~ contains all song plays from January 2017

    - ~february~ contains all song plays from February 2017

*** WITH Clause
The WITH clause stores the result of a query in a temporary table using an alias.

Multiple temporary tables can be defined with one instance of the WITH keyword.

*** Task 1
Use a left join to combine january and february on user_id and select user_id from january.

#+begin_src
  WITH january AS (
    SELECT *
    FROM plays
    WHERE strftime("%m", play_date) = '01'
  ),
  february AS (
    SELECT *
    FROM plays
    WHERE strftime("%m", play_date) = '02'
  )

  SELECT january.user_id
  FROM january
  LEFT JOIN february
  ON january.user_id = february.user_id
  WHERE february.user_id IS NULL
#+end_src

** Code Challenge 5
For this challenge, you'll use the following tables:

~months~

| column | description              |
| months | First date of each month |

~premium_users~

| column        | description                 |
| user_id       | Unique identifier for user  |
| plan_id       | ID for user's payment plant |
| purchase_date | Date user purchase premium  |
| cancel_date  | Date user cancel premium    |

*** Task 1
For each month in months, we want to know if each user in premium_users was active or cancelled. Cross join months and premium_users and select:

    - user_id from premium_users

    - purchase_date from premiun_users

    - cancel_date from premium_users

    - months from months

(Be sure to select the columns in this order)

Cross Join combine all rows of one table with all rows of another table.

#+begin_src
  SELECT premium_users.user_id,
    premium_users.purchase_date,
    premium_users.cancel_date,
    months.months
  FROM premium_users
  CROSS JOIN months;
#+end_src

** Code Challenge 6

*** Task 1
Replace the SELECT statement in your CROSS JOIN with the following statement:

#+begin_src
  SELECT premium_users.user_id,
    months.months,
    CASE
      WHEN (
        premium_users.purchase_date <= months.months
        )
        AND
        (
        premium_users.cancel_date >= months.months
        OR
        premium_users.cancel_date IS NULL
        )
      THEN 'active'
      ELSE 'not_active'
    END AS 'status'
#+end_src

This will tell us if a particular user is ~'active'~ or ~'not_active'~ each month.

** Code Challenge 7

*** Task 1
Songify has added some new songs to their catalog.

Combine ~songs~ and ~bonus_songs~ using UNION and select all columns from the result.

When we just want to stack one dataset on top of the other, the UNION operator allow us to do that.

The two tables must have the same columns and the same data types in the same order as the first table.

Since the songs table is so big, just look at a sample by LIMITing the results to 10 rows.

#+begin_src
  SELECT *
  FROM songs
  UNION
  SELECT *
  FROM bonus_songs
  LIMIT 10;
#+end_src

** Code Challenge 8
Besides stacking one table on top of another, we can also use UNION to quickly make a mini dataset:

#+begin_src
SELECT '2017-01-01' AS 'month'
UNION
SELECT '2017-02-01' AS 'month'
#+end_src

month
2017-01-01
2017-02-01

*** Task 1
Add a third UNION/SELECT so that the result contains 2017-03-01.

#+begin_src
  SELECT '2017-01-01' as month
  UNION
  SELECT '2017-02-01' as month
  UNION
  SELECT '2017-03-01' as month;
#+end_src

** Code Challenge 9

*** Task 1
The following query will give us the number of times that each song was played:

#+begin_src
  SELECT song_id,
    COUNT(*) AS 'times_played'
  FROM plays
  GROUP BY song_id;
#+end_src

Use a WITH statement to alias this code as ~play_count~ with songs and select (in this order):

    - songs table's title column

    - songs table's artist column

    - ~play_count~'s ~times_played~ column

Remember that ~play_count.song_id~ will match ~songs.id~.

#+begin_src
  WITH play_count AS (
    SELECT song_id,
    COUNT(*) AS 'times_played'
  FROM plays
  GROUP BY song_id
  )

  SELECT songs.title,
         songs.artist,
         play_count.times_played
  FROM play_count
  JOIN plays
  ON play_count.song_id = songs.id
#+end_src

* Subqueries
** Introduction to Subqueries
At this point in our SQL journey we know we can query a database to retrieve desired results. However, what happens when we query a database but we really only need a subset of the results returned? How is this situation handled when the subset of data needed spans across multiple tables?

One option that may immediately come to mind could be the use of a join. However, in this lesson, we'll explore the use of something called a subquery that gives us the same functionality as a join, but with much more readability.

*** Task 1
We will use two tables throughout this lesson, ~band_students~ and ~drama_students~.

Select the first 10 rows from each of the tables to get a feel for the data.

What are the column names?

#+begin_src
SELECT *
FROM band_students
LIMIT 10;

SELECT *
FROM drama_students
LIMIT 10;
#+end_src

The band_students has columns:

    id
    first_name
    last_name
    grade
    instrument

The drama_students has columns:

    id
    first_name
    last_name
    grade
    interest

** Subqueries
As the name suggests, a subquery is an internal query nested inside of an external query. They can be nested inside of SELECT, INSERT, UPDATE, or DELETE statements. Anytime a subquery is present, it gets executed before the external statement is run.

Subqueries are very similar to joins in terms of functionality; however, joins are more efficient and subqueries are typically more readable.

For example, if we had two tables listing students in two different clubs, ~book_club~ and ~art_club~, we could find out which students are in both tables by using a join such as:

#+begin_src
  SELECT id, first_name, last_name
  FROM book_club
  JOIN art_club
  ON book_club.id = art_club.id;
#+end_src

However, a subquery can be used to achieve the same result and is more readable:

#+begin_src
  SELECT id, first_name, last_name
  FROM book_club
  WHERE id IN (
    SELECT id
    FROM art_club);
#+end_src

In this statement, the subquery SELECT statement would be executed first, resulting in a list of student ids from the ~art_club~ table. Then, the outer query would run and select the student ids from ~book_club~ table which also appear in the subquery results.

*** Task 1
Complete the subquery to find students taking both band and drama.

#+begin_src
  SELECT first_name, last_name
  FROM band_students
  WHERE id IN (
    SELECT id
    FROM drama_students);
#+end_src

** Inserts, Updates, and Deletes
Now that we know what a subquery is and some syntax for using subqueries, let's begin looking at some of the ways subqueries can be used.

Previously, we mentioned subqueries can be placed inside of SELECT, INSERT, UPDATE, or DELETE statements. Recall that subqueries are always executed prior to the external query being run.

In the same way that the external query selects from the internal query's results, it is important to note that this same behavior takes place when the external query is an INSERT, UPDATE or DELETE. Therefore, when a subquery is nested in a DELETE statement, the rows to be deleted will be among the results from the subquery.

For example, suppose students are unable to take both history and statistics. If we wanted to delete the rows for statistics students who are also enrolled in history, we could execute a statement such as:

#+begin_src
  DELETE FROM statistics_students
  WHERE id in (
    SELECT id
    FROM history_students);
#+end_src

*** Task 1
A memo was recently released stating that 9th grade students are unable to take both drama and band concurrently. The students currently enrolled in both classes will be dropped from drama and remain in band.

Write a DELETE query that will remove 9th grade students enrolled in both band and drama from the drama_students table.

#+begin_src
  DELETE FROM drama_students
  WHERE id in (
    SELECT id
    FROM band_students);
#+end_src

** Comparison Operators
Subqueries have the unique ability to take the place of expressions in SQL queries. As such, one way of using subqueries is SQL statements is with comparison operators.

We can use operators such as ~<~, ~>~, ~=~, and ~!=~ to compare the results of the external query to those of the inner query.

For example, if Olivia decided to drop statistics and take history, we could find out how many history students are at or below her grade level by performing the following query:

#+begin_src
SELECT *
FROM history_students
WHERE grade <= (
  SELECT grade
  FROM statistics_students
  WHERE id = 1);
#+end_src

*** Task 1
Emlynne Torriti (id 20), has decided to drop band and join drama. She wants to know all of the other students in her grade level who are already enrolled in drama.

Use the tables drama_students and band_students to create a subquery that finds the students enrolled in drama that are in the same grade as Emlynne.

#+begin_src
  SELECT *
  FROM drama_students
  WHERE grade = (
    SELECT grade
    FROM band_students
    WHERE id = 20)
#+end_src

** In and Not In Clauses
One of the more common ways to use subqueries is with the use of an IN or NOT IN clause. Recall that the subquery is always executed first followed by the external query.

When an IN clause is used, results retrieved from the external query must appear within the subquery results. Similarly, when a NOT IN clause is used, results retrieved from the external query must not appear within the subquery results.

For example, we could use the below query to find out which students are enrolled in statistics and history:

#+begin_src
  SELECT *
  FROM statistics_students
  WHERE id
  IN (
    SELECT id
    FROM history_students);
#+end_src

*** Task 1
Write a query that gives the first and last names of students enrolled in band but not in drama.

#+begin_src
  SELECT first_name, last_name
  FROM band_students
  WHERE id
  NOT IN (
    SELECT id
    FROM drama_students);
#+end_src

** Exists and Not Exists
In the previous exercise we discussed the use of IN and NOT IN clauses. We also have the option of EXISTS and NOT EXISTS clauses. While EXISTS / NOT EXISTS are similar to IN / NOT IN clauses, there are some key differences. Let's explore those differences now.

Recall that when a subquery is included, the inner query runs before the external query. When the inner query is included using an IN or NOT IN clause, all rows meeting the inner query's criteria are returned and then compared against the external query's criteria. However, when the inner query is included using an EXISTS or NOT EXISTS clause, we are only checking for the presence of rows meeting the specified criteria, so the inner query only returns a true or false.

If we compare this functionality in terms of efficiency, EXISTS / NOT EXISTS are usually more efficient than IN / NOT IN clauses; this is because the IN / NOT IN has to return all rows meeting the specific criteria whereas the EXISTS / NOT EXISTS only needs to find the presence of one row to determine if a true or false value needs to be returned.

In the previous exercise, we used an example query that pulled students who are enrolled in both statistics and history using IN - the following query pulls the same information using EXISTS instead:

#+begin_src
  SELECT *
  FROM statistics_students
  WHERE EXISTS (
    SELECT *
    FROM history_students
    WHERE id = statistics_students.id
  );
#+end_src

Note that with EXISTS, we must include a WHERE clause within the subquery that defines the criteria we are checking. Here, we specify that in order for the subquery to return true, it must locate a row with the same ~id~ value as the outer query.

*** Task 1
Write a query that produces the first and last names of all the students who are enrolled in both band AND drama.

#+begin_src
  SELECT first_name, last_name
  FROM band_students
  WHERE EXISTS (
    SELECT *
    FROM drama_students
    WHERE id = band_students.id
  );
#+end_src

** Review
In this lesson we introduce SQL subqueries. We talked about why subqueries can be useful and how to use them with SELECT statements. We also reviewed how subqueries can be used in the context of INSERT, UPDATE, and DELETE statements and with comparison operators as well. Finally, we finished the lesson by demonstrating the use of subqueries with IN and NOT IN as well as EXISTS and NOT EXISTS clauses.

There's no doubt subqueries play an essential role in querying a database. Now that you've completed this lesson, you should have a better understanding of how to implement subqueries.

* Project: Welp
To practice what you've learned about joining multiple tables, you are going to use data from an exciting app called Welp. Users love Welp because it allows  them to leave reviews of businesses in their city and see how other people reviewed the businesses.

For this project, you will be working with two tables:

    - places

    - reviews

** Understanding the data

*** Task 1
Let's see what these tables contain by running the following commands:

#+begin_src
  SELECT *
  FROM places;

  SELECT *
  FROM reviews;
#+end_src

*** Task 2
If each dollar sign ($) represents $10, how could you find all places that cost $20 or less?

#+begin_src
  SELECT *
  FROM places
  WHERE price_point = '$'
    OR price_point = '$$'
#+end_src

*** Task 3
What columns can be used to JOIN these two tables?

The foreign key here is ~place_id~ in the reviews table.

Remember a foreign key is a unique identifier that matches with an id in an outside table.

** Joining the tables

*** Task 4
Let's explore how the places on Welp stand up to reviewers.

Write a query to do an INNER JOIN on the two tables to show all reviews for restaurants that have at least one review.

INNER JOIN and JOIN are functionally equivalent, but INNER JOIN can be a bit clearer to read, especially if the query has other join types (i.e. LEFT or RIGHT or CROSS) included in it.

#+begin_src
  SELECT *
  FROM places
  INNER JOIN reviews
    ON places.id = reviews.place_id;
#+end_src

*** Task 5
You probably noticed all the extra information in your results.

Modify your previous query to select only the most important columns in order to display a log of reviews by selecting the following:

   - From the ~places~ table: name, ~average_rating~

   - From the ~reviews~ table: username, rating, ~review_date~, note

#+begin_src
  SELECT places.name,
         places.average_rating,
         reviews.username,
         reviews.rating,
         reviews.review_date,
         reviews.note
  FROM places
  INNER JOIN reviews
    ON places.id = reviews.place_id;
#+end_src

*** Task 6
Now write a query to do a LEFT JOIN on the tables, selecting the same columns as the previous question.

How are the results of this query different?
Would this or the INNER JOIN be more useful for a log of reviews?

#+begin_src
  SELECT places.name,
         places.average_rating,
         reviews.username,
         reviews.rating,
         reviews.review_date,
         reviews.note
  FROM places
  LEFT JOIN reviews
    ON places.id = reviews.place_id;
#+end_src

*** Task 7
What about the places without reviews in our dataset?

Write a query to find all the ids of places that currently do not have any reviews in our reviews table.

#+begin_src
  SELECT places.id, places.name
  FROM places
  LEFT JOIN reviews
    ON places.id = reviews.place_id
  WHERE reviews.place_id IS NULL;
#+end_src

** Bonus Questions

*** Task 8
Sometimes on Welp, there are some old reviews that aren't useful anymore.

Write a query using the WITH clause to select all the reviews that happened in 2020. JOIN the places to your WITH query to see a log of all reviews from 2020.

This will use the WITH clause as well as the strftime() function. See if you can use Google to dig up some information about the function before take a look a the hint.)

To get strarted, here's how you can use strftime to get just the year from the review_date.

#+begin_src
  WITH reviews_2020 AS (
    SELECT *
    FROM reviews
    WHERE strftime("%Y", review_date) = ___)
#+end_src

*** Task 9
Businesses want to be on the lookout for difficult reviewers. Write a query that finds the reviewer with the most reviews that are BELOW the average rating for places.

To solve this, you might need to use the following in your query:

    - COUNT

    - GROUP BY

    - ORDER BY

    - LIMIT

* Multiple Tables with Reddit
For this project, you'll be working as a Data Analyst who will be examining some fictional data from Reddit, a social news aggregation, content rating site.

On Reddit, users can create posts with content such as text, media, and links to other websites. Users can post content to different communities known as subreddits, with focus on a particular topic. Users can then rate other's content by upvoting or downvoting them, and each post will show its total cumulative score.

For this task you were given three tables:

    - users: users data

    - posts: posts information

    - subreddits: information about subreddits

** Getting Familiara with the data

*** Task 1
Let's start by examining the three tables.

Write queries to select the rows from each table. Because some of the tables have many rows, select just the first 10 rows from each.

What are the column names of each table?

#+begin_src
  SELECT *
  FROM users
  LIMIT 10;

  SELECT *
  FROM posts
  LIMIT 10;

  SELECT *
  FROM subreddits
  LIMIT 10;
#+end_src

*** Task 2
What is the primary key for each table?

Can you identify any foreign keys?

The primary key of users table is id.

The primaty key of posts table is id.

The primary key of subreddits table is id.

The posts table has foreign keys ~user_id~ and ~subreddit_id~.

*** Task 3
Write a query to count how many different subreddits there are.

#+begin_src
  SELECT COUNT(*)
  AS 'subreddit_count'
  FROM subreddits;
#+end_src

*** Task 4
Write a few more queries to figure out the following information:

    - What user has the highest score?

    - What post has the highest score?

    - What are the top 5 subreddits with the highest subscriber_count?

#+begin_src
  SELECT username, MAX(score)
  AS 'Highest Score'
  FROM users

  SELECT title, MAX(score)
  AS 'Highest Score'
  FROM posts

  SELECT name, subscriber_count
  FROM subreddits
  ORDER BY subscriber_count
  DESC
  LIMIT 5;
#+end_src

** Using Joins

*** Task 5
Now let's join the data from the different tables to find out some more information.

Use a LEFT JOIN with the users and posts tables to find out how many posts each user has made. Have the users table as the left table and order the data by the number of posts in descending order.

#+begin_src
  SELECT users.username,
  COUNT(posts.id) AS 'post made'
  FROM users
  LEFT JOIN posts
  ON user.id = post.user_id
  GROUP BY users.id
  ORDER BY 2 DESC;
#+end_src

*** Task 6
Over time, posts may be removed and users might delete their accounts.

We only want to see existing posts where the users are still active, so use a INNER JOIN to write a query to get these posts. Have the posts table as the left table.

#+begin_src
  SELECT *
  FROM posts
  INNER JOIN users
  ON posts.user_id = users.user_id;
#+end_src

*** Task 7
Some new posts have been added to Reddit!

Stack the new posts2 table under the existing posts table to see them.

You can stack a dataset over another dataset using the UNION clause.

#+begin_src
  SELECT * FROM posts
  UNION
  SELECT * FROM posts2;
#+end_src

** More advanced queries

*** Task 8
Now you need to find out which subreddits have the most popular posts. We'll say that a post is popular if it has a score of at least 5000. We'll do this using a WITH and a JOIN.

First, you'll need to create the temporary table that we'll nest in the WITH clause by writing a query to select all the posts that have a score of at least 5000.

Next, place the previous query within a WITH clause, and alias this table as popular_posts.

Finally, utilize an INNER JOIN to join this table with the subreddits table, with subreddits as the left table. Select the subreddit name, the title and score of each post, and order the results by each popular post's score in descending order.

#+begin_src
  WITH popular_posts AS (
    SELECT *
    FROM posts
    WHERE score >= 5000
  )
  SELECT subreddits.name,
         popular_posts.title,
         popular_posts.score
  FROM subreddits
  INNER JOIN popular_posts
  ON subreddits.id = popular_posts.subreddit_id
  ORDER BY popular_posts.score
  DESC;
#+end_src

*** Task 9
Next, you need to find out the highest scoring post for each subreddit.

Do this by using an INNER JOIN, with posts as the left table.

#+begin_src
  SELECT subreddits.name AS 'subreddit_name',
         posts.title,
         MAX(score) AS 'highest_score'
  FROM posts
  INNER JOIN subreddits
  ON posts.subreddit_id = subreddits.id
  GROUP BY subreddits.id;
#+end_src

*** Task 10
Finally, you need to write a query to calculate the average score of all the posts for each subreddit.

Consider utilizing a JOIN, AVG, and GROUP BY to accomplish this, with the subreddits table as the left table.

#+begin_src
  SELECT subreddits.name,
  AVG(posts.score) AS 'Average Score'
  FROM subreddits
  JOIN posts
  ON subreddits.id = posts.subreddit_id
  GROUP BY 1
  ORDER BY 2 DESC;
#+end_src

* VR Startup Company
Codecademy Virtual Reality (CVR), Inc. is the latest startup on the VR scene. As head of the Projec Completion team, you have been given a list of upcoming projects needing to be delivered. Your main responsability is to analyze our current talent pool to ensure each project can be completed efficiently and effectively.

Each project needs a Project Manager, Team Lead, Designer, Database Administrator (DBA), and at least two Developers.

** Getting familiar with the data

*** Task 1
Start by familiarizing yourself with the tables. Examine the data from the employees table.

#+begin_src
  SELECT *
  FROM employees;
#+end_src

The columns are:

    employee_id
    first_name
    last_name
    location
    position
    personality
    current_project

*** Task 2
Examine the data in the projects table.

Do you think there's a way to join the two tables?

#+begin_src
  SELECT *
  FROM projects;
#+end_src

The columns are:

    project_id
    project_name
    start_date
    end_date

projects table’s project_id could be joined with employees table’s current_project.

*** Task 3
What are the names of the employees who have not chosen a project?

#+begin_src
  SELECT first_name, last_name
  FROM employees
  WHERE current_project IS NULL;
#+end_src

*** Task 4
What are the names of projects that were not chosen by any employees?

#+begin_src
  SELECT project_name
  FROM projects
  WHERE project_id NOT IN (
    SELECT current_project
    FROM employees
    WHERE current_project IS
    NOT NULL);
#+end_src

** Analizing projects and current staff

*** Task 5
What is the name of the project chosen by the most employees?

#+begin_src
  SELECT project_name
  FROM projects
  INNER JOIN employees
    ON projects.project_id =
    employees.current_project
  WHERE current_project IS NOT NULL
  GROUP BY project_name
  ORDER BY COUNT(employee_id) DESC
  LIMIT 1;
#+end_src

*** Task 6
Which projects were chosen by multiple employees?

#+begin_src
  SELECT project_name
  FROM projects
  INNER JOIN employees
    ON projects.project_id =
    employees.current_project
  WHERE current_project IS NOT NULL
  GROUP BY current_project
  HAVING COUNT (current_project) > 1;
#+end_src

*** Task 7
Each project needs at least 2 developers. How many available project positions are there for developers? Do we have enough developers to fill the needed positions?

#+begin_src
SELECT (COUNT(*) * 2) - (
  SELECT COUNT(*)
  FROM employees
  WHERE current_project IS NOT NULL
  AND position = 'Developer') AS 'Count'
  FROM projects;
#+end_src

** Bonus Questions

*** Task 8
When employees are hired at CVR, they are given the Myers_Briggs personality test. We try to diminish tension among team members by creating teams based on compatible personalities.

The chart shows which personality matches should be avoided. For example, an employee with the ISFP personality type should not be matched with an INFP, ENFP, or an INFJ.

*** Task 9
Which personality is the most common across our employees?

#+begin_src
  SELECT personality
  FROM employees
  GROUP BY personality
  ORDER BY COUNT (personality)
  DESC
  LIMIT 1;
#+end_src

*** Task 10
What are the names of projects chosen by employees with the most common personality type?

#+begin_src
SELECT project_name
FROM projects
INNER JOIN employees
  ON projects.project_id =
  employees.current_project
WHERE personality = (
  SELECT personality
  FROM employees
  GROUP BY personality
  ORDER BY
COUNT (personality) DESC
  LIMIT 1);
#+end_src

*** Task 11
Find the personality type most represented by employees with a selected project.

What are names of those employees, the personality type, and the names of the project they've chosen?

#+begin_src
  SELECT last_name, first_name,
  personality, project_name
  FROM employees
  INNER JOIN projects
    ON
  employees.current_project =
  projects.project_id
  WHERE personality = (
    SELECT personality
    FROM employees
    WHERE current_project IS NOT NULL
    GROUP BY personality
    ORDER BY
  COUNT(personality) DESC
    LIMIT 1);
#+end_src

*** Task 12
For each employee, provide their name, personality, the names o any projects they've chosen, and the number of incompatible coworkers.

#+begin_src
SELECT last_name, first_name, personality, project_name,
CASE
   WHEN personality = 'INFP'
   THEN (SELECT COUNT(*)
      FROM employees
      WHERE personality IN ('ISFP', 'ESFP', 'ISTP', 'ESTP', 'ISFJ', 'ESFJ', 'ISTJ', 'ESTJ'))
   WHEN personality = 'ISFP'
   THEN (SELECT COUNT(*)
      FROM employees
      WHERE personality IN ('INFP', 'ENTP', 'INFJ'))
   -- ... etc.
   ELSE 0
END AS 'IMCOMPATS'
FROM employees
LEFT JOIN projects on employees.current_project = projects.project_id;
#+end_src

* Artificial Intelligence for SQL
** Introduction
Whether you are an experienced SQL user or just starting out with databases, artificial intelligence (AI) models can streamline your approach to SQL queries and data manipulation.

In this lesson, we'll cover how to use AI systems (like ChatGPT or Gemini) to:

    - brainstorm analytics ideas

    - write SQL code

    - debug SQL errors

Along the way, we'll also explore pitfalls of working with AI like:

    - hallucinations

    - data privacy and security

    - legal concerns

    - ethical concerns

By effectively using AI, we can harness the combined power of human expertise and artificial intelligence to streamline database operations and unlock new insights from your data.

Promt: Write a query for returning the column named "student_name" in the table named "class".

Answer: To retrieve the “student_name” column from the “class” table, you can use the following SQL query:

SELECT student_name FROM class;

** What is a prompt?
AI chat systems (like ChatGPT and Gemini) are called "large language models" (LLMs) because they are trained on massive text datasets.

Through this training process, LLMs "learn" patterns and relationships between words in a language.

Given a starting point, like a question, an LLM can use these learned patterns to generate plausible responses.

That starting point is what we call a prompt.

Prompt engineering is the art of designing prompts that result in the most effective output from an LLM.

For example, suppose we're trying to analyze the sales dataset of a small business. We might ask an LLM for help with a prompt like

#+begin_src
  Write a SQL query to retrieve sales data for analysis
#+end_src

We sent this prompt to ChatGPT, and got the following query:

#+begin_src
  SELECT *
  FROM sales_data;
#+end_src

While this is a perfectly fine query, we probably could have written this one ourselves!

In order to get the best results from an LLM, we will need to provide a lot more context about the structure of our dataset and our analytical goals.

In the rest of this lesson, we'll explore interacting with LLMs under the following guidelines:

    - use clear language

    - understand and communicate the purpose of the prompt

    - include important context

    - provide examples to guide the AI's output toward a specific format

*** Task 1
Run these prompts and read the results. What do you notice?

    - Prompt 1: Retrieve sales data from this month-

    - Prompt 2: Retrieve data from the SQL table ~sales~, limiting the ~date~ to the month of March

** Structuring an AI Conversation
It can be tempting to spend a lot of time crafting the "perfect prompt" to get the exact output we want. But it is often more efficient (and more powerful) to converse back and forth with the AI assistant throughout the analytics process, iterating and improving upon the AI output as we go.

By using a conversational approach, we

    - Avoid repeating the same information in multiple prompts

    - Save time crafting overly detailed prompts

    - Build the habit of reflecting and iterating on the AI output

This last step is crucial. Remember, while AI can provide valuable insights, it's not infallible. We shouldn't use AI output unless we understand how it works!

We recommend the following outline for interacting with AI:

    - Explain the goal (I'm working on an analytics report about electric vehicles)

    - Provide context (I have three tables with the following names)

    - State your request clearly (Write a query to determine the most efficient vehicle)

    - Review and refine (Can you explain this piece of the query you generated:)

    - Continuing the conversation(That's great, what other types of statistics should I look into for this report?)

Alright, buckle up! Let's complete a simple task while having a fun conversation with the AI chatbot.

Important notes:

    - throughout the lesson, we include our sample prompts within each Hint. Feel free to take a look any time you get stuck!
    - some checkpoints only involve chatting with the AI, to receive the check mark and move to the next checkpoint, select Run under the code editor.

*** Task 1
We’ll explore techniques for writing individual prompts in later exercises, but for this exercise let’s play around with having a basic conversation with the AI! Don’t worry about getting everything perfect yet, but you may be surprised at how well the AI does even with basic prompts.

Begin by examining the table models. Run the query below to return all the columns present inside the models table:

SELECT * FROM models;

Note that best_mpge contains the mile-per-gallon equivalent under optimal conditions, a number that allows us to compare the efficiency of electric vehicles to gasoline counterparts, and so forth.

*** Task 2
Write an overview of the models table in the AI chat, providing information on all the column names to the AI.

Note that while this may seem tedious, it will save a lot of time and trouble down the line.

    - First, explain that we have a SQL database with a models table

    - Provide de columns names

    - Explain that we'll be asking for SQL prompts based on this table

A sample prompt for inspiration

#+begin_src
  My SQL database has a table called models.
  It has the following columns:

  model_id | model | year | manufacturer_id |
  fuel_id | best_mpge

  I will ask some questions based on this table,
  and you will have to provide SQL queries for them.
#+end_src

*** Task 3
We'd like to know which manufacturer has produced the most efficient vehicles on average. Write a prompt asking the AI to produce a SQL query returning this information.

Note that in this table, we'll only be able to identify the ~manufacturer_id~, but we'll work on joining multiple tables later in the lesson.

The efficiency of the vehicle is in ~best_mpge~, since MPGe is the miles-per-gallon equivalent for non-gasoline vehicles.

#+begin_src
  Write a query to identify the manufacturer that the largest average "best_mpge"
#+end_src

The code received:

#+begin_src
  SELECT manufacturer_id, AVG(best_mpge) AS avg_best_mpge
  FROM models
  GROUP BY manufacturer_id
  ORDER BY avg_best_mpge DESC
  LIMIT 1;
#+end_src

*** Task 4
Now, let's find the top ten most efficient models. Write a prompt, and run the code the AI returns!

#+begin_src
  Now, write a SQL query to return the top 10 most efficient models
#+end_src

The code we received:

#+begin_src
  SELECT *
  FROM models
  ORDER BY best_mpge DESC
  LIMIT 10;
#+end_src

** Providing context
Alright, now that we have a bit of practice conversing with AI, let's dig into how to craft the best individual prompts.

AI systems require *context* to produce relevant results.

For example, we sent the prompt ~write a select query~ to both ChatGPT and Gemini. Here are the responses that we got:

    - ChatGPT: Of course! Could you please specify the database schema and the table you'd like to query, as well as any specific conditions or criteria you want to include in the query? This information will help me provide you with an accurate select query.

    - Gemini: SELECT column1, column2, FROM ~table_name~;

These aren't totally unhelpful responses! ChatGPT asked for more details, and Gemini provided a template for a query that we could fill out with our specific database information.

But to get the most helpful responses, we want to provide the kind of context ChatGPT asked for. In this exercise, we'll stick to working with a single table.

For an ideal prompt, we'll want to include:

    - The name and topic of the table

    - The relevant column names

    - The specific output we want

For example, suppose we're analyzing the alternate-fuel vehicle industry. Our database has a models table with data on each alternate fuel model (such as a Tesla).

The ~models~ table includes a column labeled ~best_mpge~, which records the mile-per-gallon equivalent for each vehicle model under optimal conditions. This is a value that lets us compare traditional gasoline vehicles to newer vehicles like electric cars. We've been asked to determine the 5 most fuel-efficient vehicles.

Here's a sample prompt:

#+begin_src
  The database table "models" has data regarding
  alternative fuel vehicles. I need a SQL query
  to extract the top 5 models by column "best_mpge".
#+end_src

Notice how we've communicated

    - The name of the table

    - The name of the relevant column

    - The output we want

The output we received from ChatGPT is exactly what we wanted:

#+begin_src
  SELECT * FROM models
  ORDER BY best_mpge DESC
  LIMIT 5;
#+end_src

*** Task 1
Run the SQL query given below to get familiar with all the columns present in the models table:

#+begin_src
  SELECT * FROM models LIMIT 5;
#+end_src

*** Task 2
Let's explore the ~models~ table.

Our goal is to identify the 10 oldest models in our dataset. Write an AI prompt to produce a query. Once you receive a query, run it in the code editor.

Challenge mode: phrase your prompt carefully so that the query you get back needs as little editing as possible!

What was the oldest model?

When creating the prompt, make sure the context is clear and you correctly mention the table and column names.

#+begin_src
  Prompt 1: the database table models has data
  regarding alternative fuel vehicles. I'm going
  to ask for specific queries. When I do, I'd
  like you to add sorting statements to make the
  data easier to analyze. Got it?

  Prompt 2: Write a SQL query to return the ten
  oldest models based on the column "year"
#+end_src

#+begin_src
  SELECT *
  FROM models
  ORDER BY year
  LIMIT 10;
#+end_src

*** Task 3
Has the average fuel efficiency improved over the years? Ask the AI for a query that calculates the average miles-per-gallon equivalent for each year in the models table.

When creating the prompt make sure the context is clear and you correctly mention the table and column names.

We'll use the same conversation as before, so we don't need to repeat info.

Prompt 3 in the conversation:

#+begin_src
  Write a SQL query that returns the average 'best_mpge' by 'year'.
#+end_src

#+begin_src
  SELECT year,
  AVG(best_mpge) AS
  avg_best_mpge
  FROM models
  GROUP BY year;
#+end_src

** Multiple Tables
Often, SQL databases have multiple related tables. When working wint AI, you'll need to communicate:

    - What tables are in the database

    - The columns that connect the tables

For example, suppose we want calculate the average MPG-equivalent for each manufacturer.

We might start the AI conversation with

#+begin_src
  I'm analyzing a database. I'll ask you for SQL
  queries. Got it?
#+end_src

Then, we could follow up with our specific ask:

#+begin_src
  Here are two tables with relevant columns:
  `models` has columns `manufacturer_id`
  and `best_mpge`
  `manufacturers` has columns
  `manufacturer_id` and `manufacturer`

  create a SQL query that calculates the average `best_mpge` by `manufacturer`
#+end_src

The resulting query we got:

#+begin_src
SELECT manufacturers.manufacturer, AVG(models.best_mpge) AS average_best_mpge
FROM models
JOIN manufacturers ON models.manufacturer_id = manufacturers.manufacturer_id
GROUP BY manufacturers.manufacturer;
#+end_src

A couple important points:

    1. In this case, we only provided the relevant columns to save time. If we're planning on an extended analysis with multiple queries, we might lead with the full table schemas (lists of columns names).

    2. The LLM was able to pick up on manufacturer_id as the join column because of the way it was named! This saved us from having to specify. However, we may run into cases where we'll have to be more explicit.

    3. The LLM assumed we wanted an INNER join. It is always worth noting the assumptions the LLM makes, because there may be cases where we want a different kind of join.

    4. Note that LLMs will often alias tables (giving them shorter names). This is fine, but if we find it hard to track which table is names what, we can always iterate with a prompt like "please rewrite without table aliases."

*** Task 1
The fuels table contains data on which type of fuel each vehicle uses.

Run the query

#+begin_src
  SELECT * FROM fuels;
#+end_src

to learn how this table is structured, and what kinds of fuels are included in the database.

*** Task 2
We'd like to identify the oldest electric fuel vehicles.

Have a conversation with the AI, with the goal of producing a query that returns the 10 oldest electric fuel models.

Make sure to include the relevant column names, including the column that connects the two tables.

Tip: spelling and capitalization matter for column names and for what is contained in the column. Querying for "Electric" will be different than "electric".

*Prompt:* Here are two tables with relevant columns:

models contains the fuel_id, year, and models fuels contains the fuel_id and the specific fuel.

Write a SQL query returning the 10 oldest vehicles with electric fuel

#+begin_src
  SELECT models.model, models.year, fuels.fuel
  FROM models
  JOIN fuels ON
  models.fuel_id = fuels.fuel_id
  WHERE fuels.fuel = 'electric'
  ORDER BY models.year
  LIMIT 10;
#+end_src

*** Task 3
Now, try to use the AI to identify the manufacturer with the most hybrid electric models.

We'll use the same chat as before, so we don't need to remind the AI of the table structure.

*Prompt:* This time join models, manufacturers, and fuels table to find the manufacturer with the most amount of hybrid vehicles where fuel = hybrid electric.

#+begin_src
SELECT manufacturers.manufacturer, COUNT(models.model) AS num_hybrid_vehicles
FROM models
JOIN manufacturers ON models.manufacturer_id = manufacturers.manufacturer_id
JOIN fuels ON models.fuel_id = fuels.fuel_id
WHERE fuels.fuel = 'hybrid electric'
GROUP BY manufacturers.manufacturer
ORDER BY num_hybrid_vehicles DESC
LIMIT 1;
#+end_src

** Specify Output Structure
Sometimes it can feel like writing a prompt is basically just writing SQL pseudocode.

For example, here's a prompt to count the number of models for each manufacturer and fuel type:

#+begin_src
  Write a query that joins the `manufacturers`
  and `models` tables to the `fuels` table using
  the `manufacturer_id` and `fuel_id` as the join
  columns. Then, group by `manufacturer` and `fuel`
  and count the number of models.
#+end_src

At this point, we're practically writing the SQL, just in slightly more natural language. Another option is to provide the structure of the query output, an let the AI fill in the details of what we want.

For example, here's a prompt with the same goal, but without specifying as many details:

#+begin_src
I have three database tables: models, manufacturers, and fuels. they join using the columns fuel_id and manufacturer_id
I want a SQL query that produces a table structured as follows:
| manufacturers.manufacturer | fuels.fuel | number_of_models |
#+end_src

A few important points:

   1. We described the three tables and how they join

   2. We used table.column notation to communicate which colum belongs to which table

   3. We used a descriptive name for the third column (number_of_models) in the hope that the AI would calculate this column appropriately

Here's the output we got from this prompt:

#+begin_src
SELECT m.manufacturer AS manufacturer,
       f.fuel AS fuel,
       COUNT(*) AS number_of_models
FROM manufacturers m
JOIN models mo ON m.manufacturer_id = mo.manufacturer_id
JOIN fuels f ON mo.fuel_id = f.fuel_id
GROUP BY m.manufacturer, f.fuel;
#+end_src

Pretty good, right? Recall that if we’re getting confused about which table m is, we can always iterate and ask “please rewrite without table aliases.”

*** Task 1
Suppose we have been asked to analyze how efficient (in terms of ~best_mpge~) each manufacturer is at using each type of fuel.

Design a target table structure to answer this question, and prompt the AI to produce SQL.

Try running the SQL - did your prompt communicate all the necessary information?

One potential table structure has the columns manufacturer, fuel, and average_best_mpge.

#+begin_src
  Write a SQL query that transforms the manufacturer
  and fuel tables into the table below:

  manufacturers.manufacturer |
  fuels.fuel |
  average(model_best_mpge)

  using fuel_id as the join column.
#+end_src

#+begin_src
SELECT m.manufacturer, f.fuel, AVG(mod.best_mpge) AS average_best_mpge
FROM manufacturers m
JOIN models mod ON m.manufacturer_id = mod.manufacturer_id
JOIN fuels f ON mod.fuel_id = f.fuel_id
GROUP BY m.manufacturer, f.fuel;
#+end_src

*** Task 2
Imagine we've been asked to calculate which manufacturers make the most electric vehicles, the most hybrid vehicles, and so on.

Design a table to capture this information using the data from the models, manufacturers, and fuels tables. Design a prompt communicating this information to the AI, and run the returned query.

*Prompt:* Using the same tables, write a SQL query to produce a table with the following structure:

manufacturer | fuel | count_of_models

#+begin_src
SELECT m.manufacturer, f.fuel, COUNT(*) AS count_of_models
FROM manufacturers m
JOIN models mod ON m.manufacturer_id = mod.manufacturer_id
JOIN fuels f ON mod.fuel_id = f.fuel_id
GROUP BY m.manufacturer, f.fuel;
#+end_src

* SQLite

** Main Features
SQLite is a software library that provides a *relational database management system*. The lite in SQLite means lightweight in terms of setup, database administration, and required resources.

SQLite has the following noticeable features:

    - Self-contained

    - Serverless

    - Zero-configuration

    - Transaccional

*** Serverless
An RDBMS such as MySQL, PostgreSQL, etc., normally requires a separate server process to run. The applications that want to access the database server use TCP/IP protocol to send and receive requests. This is called client/server architecture.

The following diagram illustrates the RDBMS client/server architecture:

[[./RDBMS-Client-Server-Architecture.jpg]]

SQLite does NOT work this way.

SQLite does NOT require a server to run.

SQLite database is integrated with the application that accesses the database.

The applications interac with the SQLite database reading and writing directly from the database files stored on disk.

The following diagram illustrates the SQLite server-less architecture:

[[./What-is-SQLite.jpg]]

*** Self-Contained
SQLite is self-contained, which means it requires minimal support from the operating system or external library. This makes SQLite usable in any enviroment, especially in embedden devices like iPhones, Android phones, game consoles, handheld media players, etc.

*** Zero-configuration
Because of the serverless architecture, you don't need to install SQLite before using it. No server process needs to be configured, started, and stopped.

In addition, SQLite does not use any configuration files.

*** Transactional
All transactions in SQLite are fully ACID-compliant, which means all queries and changes are Atomic, Consistent, Isolated, and Durable.

In other words, all changes within a transaction take place completely or not at all even when an unexpected situation like an application crash, power failure, or operating system crash occurs.

** SQLite distintive features
SQLite uses dynamic types for tables. It means you can store any value in any column, regardless of the data type.

SQLite allows a single database connection to access multiple database files simultaneously. This brings many nice features like joining tables in different databases or copying data between databases in a single command.

SQLite is capable of creating in-memory databases that are very fast to work with.

** SQLite Sample Database
We provide you with the SQlite sample database named Chinook. The Chinook sample database is a good database for practicing SQL, especially SQLite.

The following database diagram illustrates the Chinook database tables and their relationships.

[[./sqlite-sample-database-diagram-color.pdf]]

*** Chinook sample database tables
The Chinook sample database has 11 tables as follows:

    - ~employees~ table stores employee data such as id, last name, firs name, etc. It also has a field named ~ReportsTo~ to specify who reports to whom.

    - ~customers~ table stores customer data

    - ~invoices~ & ~invoice_items~ tables: these two tables store invoice data. The ~invoices~ table stores invoice header data and the ~invoice_items~ table stores the invoice line items data.

    - ~artists~ table stores artist data. It is a simple table that contains the id and name.

    - ~albums~ table stores data about a list of tracks. Each album belongs to one artist. However, one artist may have multiple albums.

    - ~media_types~ table stores media types such as MPEG audio and AAC audio files.

    - ~genres~ table stores music types such as rock, jazz, metal, etc.

    - ~tracks~ table stores the data of songs. Each track belongs to one album.

    - ~playlists~ & ~playlist_track~ tables: ~playlists~ table stores data about playlists. Each playlist contains a list of tracks. Each track may belong to multiple playlists. The relationship between the ~playlists~ and ~tracks~ tables is many-to-many. The ~playlist_track~ table is used to reflect this relationship.

** SQLite Commands
The SQLite project delivers a simple command-line tool named sqlite3 that allows you to interact with the SQLite databases using SQL statements and commands.

*** Connect to an SQLite database
To start the sqlite3, you type the sqlite3 as follows:

#+begin_src
>sqlite3
#+end_src

By default, an SQLite session uses the in-memory database, therefore, all changes will be gone when the sessions ends.

To open a database file, you use the ~.open FILENAME~ command. The following statement opens the ~chinook.db~ database:

#+begin_src
sqlite> .open  /home/oldoc/learningDS/mlSpecialty/SQL/chinook.db
#+end_src

If you want to open a specific database file when you connect to the SQLite database, you use the following command:

#+begin_src
>sqlite3 /home/oldoc/learningDS/mlSpecialty/SQL/chinook.db
#+end_src

If you start a session with a database name that does not exist, the sqlite3 tool will create the database file.

*** Show all available commands and their purposes
To show all available commands and their purpose, you use the ~.help~ command as follows:

#+begin_src
.help
#+end_src

*** Show databases in the current database connection
To show all databases in the current connection, you use the ~.databases~ command. The ~.databases~ command displays at least one database with the name: ~main~.

For example, the following command shows all the databases of the current connection:

#+begin_src
sqlite> .database
#+end_src

To attach a database to the current connection, you use the statement ATTACH DATABASE. The following statement adds the chinook database to the current connection.

#+begin_src
sqlite> ATTACH DATABASE "/home/oldoc/learningDS/mlSpecialty/SQL/chinook.db" AS Chinook;
#+end_src

*** Exit sqlite3 tool
To exit the sqlite3 program, you use the .exit command.

#+begin_src
sqlite> .exit
#+end_src

*** Show tables in a database
To display all the tables in the current database, you use the .tables command. The following commands open a new database connection to the chinook database and display the tables in the database.

#+begin_src
> sqlite3 chinook.db
#+end_src

#+begin_src
sqlite> .tables
#+end_src

If you want to find tables based on a specific pattern, you use the .table pattern command. The sqlite3 uses the LIKE operator for pattern matching.

For example, the following statement returns the table that ends with the string ~es~.

#+begin_src
sqlite> .table '%es'
#+end_src

*** Show the structure of a table
To display the structure of a table, you use the ~.schema TABLE~ command. The TABLE argument could be a pattern. If you omit it, the ~.schema~ command will show the structures of all the tables.

#+begin_src
sqlite> .schema albums
#+end_src

To show the schema and the content of the ~sqlite_stat~ tables, you use the .fullschema command.

#+begin_src
sqlite> .fullschema
#+end_src

*** Show indexex
To show all indexes of the current database, you use ~.indexes~ command as follows:

#+begin_src
sqlite> .indexes
#+end_src

To show the indexes of a specific table, you use the ~.indexes TABLE~ command. For example, to show indexes of the ~albums~ table, you use the following command:

#+begin_src
sqlite> .indexes albums
#+end_src

To show indexes of the tables whose names end with es, you use a pattern of the LIKE operator.

#+begin_src
sqlite> .indexes %es
#+end_src

*** Save the result of a query into a file
To save the result of a query into a file, you use the ~.output FILENAME~ command. Once you issue the ~.output~ command, all the results of the subsequent queries will be saved to the file that you specified in the ~FILENAME~ argument. If you want to save the results of the next single query only to the file, you issue the ~.once FILENAME~ command.

To display the result od the query to the standard output again, you issue the ~.output~ command /without arguments./

The following commands select the ~title~ form the ~albums~ table and write the result to the ~albums.txt~ file.

#+begin_src
sqlite> .output albums.txt
sqlite> SELECT title FROM albums;
#+end_src

*** Execute SQL statements from a file
Suppose we have a file named commands.txt in a directory folder with the following content:

#+begin_src
SELECT albumid, title
FROM albums
ORDER BY title
LIMIT 10;
#+end_src

To execute the SQL statements in the commands.txt file, you use the .read FILENAME command as follows:

#+begin_src
sqlite> .mode column
sqlite> .header on
sqlite> .read commands.txt
#+end_src

** Basic SQLite tutorial
This section presents basic SQL statements that you can use with SQLite. You will first start querying data from the sample database. If you are already familiar with SQL, you will notice the differences between SQL standard and the SQL dialect used in SQLite.

*** SQLite Select
The SELECT statement is one of the most commonly used statements in SQL. The SQLite SELECT statement provides all features of the SELECT statement in SQL standard.

**** Simple uses of SELECT statement
The following example show how to use the SELECT statement to perform a simple calculation:

#+begin_src
SELECT 1 + 1;
#+end_src

You can use multiple expressions in the  SELECT statement as follows:

#+begin_src
SELECT
  10 / 5,
  2 * 4;
#+end_src

**** Querying data from a table using the SELECT statement
We often use the SELECT statement to query data from one or more tables.

Here's the syntax of the SELECT statement:

#+begin_src
SELECT DISTINT column_list
  FROM table_list
  JOIN table ON join_condition
  WHERE row_filter
  ORDER BY column
  LIMIT count OFFSET offset
  GROUP BY column
  HAVING group_filter;
#+end_src

The SELECT statement is the most complex statement in SQLite. To make it easier to understand each part, we will break the SELECT statement into multiple easy-to-understand tutorials.

    - Use the ORDER BY clause to sort the result set.

    - Use the DISTINCT clause to query unique rows in a table.

    - Use the WHERE clause to filter rows in the result set.

    - Use the LIMIT OFFSET clause to constrain the number of rows returned.

    - Use the INNER JOIN or LEFT JOIN to query data from multiple tables using join.

    - Use the GROUP BY clause to group rows into groups and apply aggregate functions to each group.

    - Use the HAVING clause to filter groups.

In this tutorial, we'll focus on the simplest form of the SELECT statement that allows you to query data from a single table:

#+begin_src
SELECT column_list
  FROM table;
#+end_src

Even though the SELECT clause appears before FROM clause, SQLite evaluates the FROM clause first and then the SELECT clause, therefore:

    - First, specify the table from which you want to get data in FROM clause. Notice that you can have more than one table in the FROM clause. We'll discuss it in the subsequent tutorial.

    - Second, specify a column or a list of comma-separated columns in the SELECT clause.

You use the semicolon (;) to terminate the statement.

**** SQLite SELECT Examples
Let's take a look at the ~tracks~ table in the sample database.

The tracks table contains columns and rows. It looks like a spreadsheet.

To get data from the tracks table such as trackid, track name, composer, and unit price, you use the following statement:

#+begin_src
SELECT
  trackid,
  name,
  composer,
  unitprice
FROM
  tracks;
#+end_src

You specify a list column names, from which you want to get data, in the SELECT clause and the tracks table in the FROM clause.

#+begin_src
SELECT
  trackid,
  name,
  albumid,
  mediatypeid,
  genreid,
  composer,
  milliseconds,
  bytes,
  unitprice

FROM
  tracks;
#+end_src

For a table with many columns, the query would be so long that time-consuming to type. To avoid this, you can use the asterisk (*), which is the shorthand for all columns of the table as follows:

#+begin_src
SELECT * FROM tracks;
#+end_src

The query is shorter and cleaner now.

However ...

You should use the asterisk (*) for testing purposes only, not in the application development.

Because ...

When you develop an application, you should control what SQLite returns to your application. Suppose, a table has 3 columns, and you use the asterisk (*) to retrieve the data from all three columns.

What if someone removes a column, your application would not be working properly, because it assumes that there are three columns returned, and the logic to process those three columns would be broken.

If someone adds more columns, your application may work but it gets more data than needed, which creates more I/O overhead between the database and application.

So try to avoid using the asterisk (*) as a good habit when you use the SELECT statement.

*** SQLite Order By

**** Introduction to SQLite ORDER BY clause
SQLite stores rows in a table in an unspecified order. It means that the rows in the table may or may not be in the order they were inserted.

If you use the SELECT statement to retrieve rows from a table, the order of rows in the result set is unspecified.

To sort the rows in a result set, you add the ORDER BY clause to the SELECT statement as follows:

#+begin_src
SELECT
  select_list
FROM
  table
ORDER BY
  colum_1 ASC,
  colum_2 DESC;
#+end_src

The ORDER BY  clause comes after the FROM clause. It allows you to sort the result set based on one or more columns in ascending or descending order.

In this syntax, you place the column name by which you want to sort after the ORDER BY clause followed by the ASC or DESC keyword.

    - The ASC keyword means ascending.

    - The DESC keyword means descending.

If you don't specify the ASC or DESC keyword, SQLite sorts the result set using the ASC option. In other words, it sorts the result set in ascending order by default.

If you want to sort the result set by multiple columns, you use a comma (,) to separate two columns.

The ORDER BY clause sorts rows using columns or expressions from left to right. In other words, the ORDER BY clause sorts the rows using the first column in the list. Then, it sorts the sorted rows using the second column, and so on.

SQLite allows you to sort the result set using columns that do not appear in the select list of the SELECT clause.

**** SQLite ORDER BY clause examples
Let's take the tracks table in the sample database for the demonstration.

Suppose, you want to get data from name, milliseconds, and album id columns, you use the following statement:

#+begin_src
SELECT
  Name,
  Milliseconds,
  AlbumId
FROM
  tracks;
#+end_src

The SELECT statement that does not use ORDER BY clause returns rows that are in an unspecified order.

Suppose you want to sort the result set based on AlbumId column in ascending order, you use the following statement:

#+begin_src
SELECT
  name,
  milliseconds,
  albumid
FROM
  tracks
ORDER BY
  albumid ASC;
#+end_src

The result set now is sorted by the AlbumId column in ascending order as shown in the screenshot.

SQLite uses ASC by default so you can omit it in the above statement as follows:

#+begin_src
SELECT
  name,
  milliseconds,
  albumid
FROM
  tracks
ORDER BY
  albumid;
#+end_src

Suppose you want to sort the sorted result (by AlbumId) above by the Milliseconds column in descending order. In this case, you need to add the Milliseconds column to the ORDER BY clause as follows:

#+begin_src
SELECT
  name,
  milliseconds,
  albumid
FROM
  tracks
ORDER BY
  albumid ASC,
  milliseconds DESC;
#+end_src

SQLite sorts rows by ~AlbumId~ in ascending order first. Then, it sorts the sorted result set by the ~Milliseconds~ column in descending order.

If you look at the tracks of the album with AlbumId 1, you'll find that the order of tracks changes between the two statements.

**** SQLite ORDER BY with the column position
Instead of specifying the names of columns, you can use the column's position in the ORDER BY clause.

For example, the following statement sorts the tracks by both AlbumId (3rd column) and Milliseconds (2nd column) in ascending order.

#+begin_src
SELECT
  name,
  milliseconds,
  albumid
FROM
  tracks
ORDER BY
  3,
  2;
#+end_src

The number 3 and 2 refers to the AlbumId and Milliseconds in the column list that appears in the SELECT clause.

**** Sorting NULLs
In the database world, NULL is special. It denotes that the information in missing or the data is not applicable.

Suppose you want to store the birthday of an artist in a table. At the time of saving the artist's record, you don't have the birthday information.

To represent the unknown birthday information in the database, you may use a special date like 01.01.1990 or an '' empty string. However, these values do not clearly show the birthday is unknown.

NULL was invented to resolve this issue. Instead of using a special value to indicate that the information is missing, NULL is used.

NULL is special because you cannot compare it with another value. Simply put, if the two pieces of information are unknown, you cannot compare them.

NULL is even cannot be compared with itself; NULL is not equal to itself so NULL = NULL always results false.

When it comes to sorting, SQLite considers NULL to be smaller than any other value.

It means that NULLs will appear at the beginning of the result set if you use ASC or at the end of the result set when you use DESC.

SQLite 3.30.0 added the NULLS FIRST and NULLS LAST options to the ORDER BY clause. The NULLS FIRST option specifies that the NULLs will appear at the beginning of the result set while the NULLS LAST option places NULLs at the end of the result set.

The following example uses the ORDER BY clause to sort tracks by composers:

#+begin_src
SELECT
  TrackId,
  Name,
  Composer
FROM
  tracks
ORDER BY
  Composer;
#+end_src

First, NULLs appear at the beginning of the result set because SQLite treats them as the lowest values. When you scroll down the result, you will see other values.

The following example uses the NULLS LAST option to place NULLs after other values:

#+begin_src
SELECT
  TrackId,
  Name,
  Composer
FROM
  tracks
ORDER BY
  Composer NULLS LAST;
#+end_src

If you scroll down the output, you will see that NULLs are placed at the end of the result set.

**** Summary
    - Use the SQLite ORDER BY clause to sort rows by one or more columns in ascending and descending orders.

    - Use ASC to sort rows in ascending order.

    - Use DESC to sort rows in descending order.

    - Use the NULLS FIRST option to place NULLs before other non-null values.

    - Use the NULLS LAST option to place NULL after other non-null values.

* Quiz (For Data Scientist / ML Specialist)

** Practice

*** Question 1
Fill in the blanks to complete the statements about causal analysis:

    - Carefully designed experiments that support causal analysis *randomly* assign subjects to treatment groups, *control* factors that could affect the experiment outcome, and are *replicated*.

*** Question 2
Given a table called snacks with columns name, price, and containsPeanuts, which statement finds the average price of all snacks that do not contain peanuts?

#+begin_src
SELECT AVG(price)
  FROM snacks
  WHERE containsPeanuts = "no";
#+end_src

Good job! Only the prices of snacks without peanuts are used to calculate the average.

*** Question 3
What is the difference between quantitative and categorical variables?

- Quantitative variables represent amounts, whereas categorical variables represent groupings.

*** Question 4
True or False?

Conclusions drawn from a descriptive analysis with one dataset can be extended to other datasets.

- False

  Great Job! Conclusion drawn from descriptive analysis with a dataset cannot be extended beyond the dataset actually analyzed.

*** Question 5
Given the 2D list, how would you print the value 3 using its index?

#+begin_src python :results output
my_list = [['a', 'b', 'c'], [1, 2, 3], ['d', 'e', 'f']]
print(my_list[1][2])
#+end_src

#+RESULTS:
: 3

*** Question 6
What will the following code set ~x~ to?

#+begin_src python :results output
  x = 26 % 4
  print(x)
#+end_src

#+RESULTS:
: 2

Correct! The remainder when dividing 26 by 4 is 2.

*** Question 7
What is returned when ~.find()~ is called on the following string?

#+begin_src python :results output
  str = "Yipeeee"
  print(str.find("e"))
#+end_src

#+RESULTS:
: 3

Correct! .find() only returns the first occurrence of the string passed to it.

*** Question 8
Which SQL function is used to find the minimum value of a group?

    - MIN()

      Correct! The SQL MIN() aggregate function returns the smallest item value from a group.

*** Question 9
You would like to know the overall sentiment of your peers in regard to the Campus Cafeteria, and have gathered data through a survey. Your dataset ~cafe_survey~ contains several variables. Match each variable to its correct type (Ordinal or Nominal).

*** Question 10
Write a function named first_three_multiples() that has one parameter named num.

This function should print the first three multiples of num. Then, it should return the third multiple.

For example, first_three_multiples(7) should print 7, 14, and 21 on three different lines, and return 21.

*Hint*
For this function, we need to print() out the results of each multiplication * then return a single value. For example, printing the result of 3 times 5 wouldo look like print(3 * 5) and returning it would look like return 3 * 5.

#+begin_src python :results output

  # Write your first_three_multiples function here
  def first_three_multiples(num):
      print(num)
      print(num * 2)
      print(num * 3)

      return print(num * 3)

  first_three_multiples(10)
#+end_src

#+RESULTS:
: 10
: 20
: 30
: 30

*** Question 11
Which string is matched by regular expression ^ab?

    - abc
      The regex ^ab matches string abc as it starts with text ab

*** Question 12
What is the built-in method in Python that allows you to inspect the first few rows of a pandas DataFrame?

    - .head()

      Correct! You can use .head() with a dataframe to see the first few rows.

*** Question 13
Two-sample t-test, ANOVA, and Tukey's range test all do NOT assume ...

    - Groups created by categorical variables are dependent of each other.

*** Question 14
Given the system of equations below, fill in the blanks for the NumPy representation when converted to Ax=b form.

#+begin_src
 ## Converting the System to Ax=b Form

 Given system of equations:
 2x + 2y = 1
 4 - x = 3y

 Rearranging the second equation:
 -x - 3y = -4

 Matrix form Ax=b:

| 2  2 |  | x |  =  | 1 |
| -1 -3 | | y |  =  | -4 |


NumPy representation:

import numpy as np

A = np.array([[2, 2], [-1, -3]])
b = np.array([1, -4])

Therefore, the NumPy representation is:
A = np.array([[2, 2], [-1, -3]])
b = np.array([1, -4])

#+end_src

*** Question 15
Put a variable in the print() function which will not raise any error.

#+begin_src python :results output
  def get_prescription():
      advice = "Drink plenty of water."
      hospital_charge = 15
      return advice

  prescription = get_prescription()
  print(prescription)
#+end_src

#+RESULTS:
: Drink plenty of water.


*** Question 16
What is the value of the balance variable printed at last?

#+begin_src python :results output
  balance = 1000

  def withdraw(current_balance, amount):
      current_balance = current_balance - amount
      print('Withdrawing money.')
      return current_balance

  def deposit(current_balance, amount):
      current_balance = current_balance + amount
      print('Depositing money.')
      return current_balance

  balance = withdraw(balance, 100)
  balance = withdraw(balance, 50)
  balance = balance + 10
  balance = deposit(balance, 100)
  print(balance)
#+end_src

#+RESULTS:
: Withdrawing money.
: Withdrawing money.
: Depositing money.
: 960

*** Question 17
What was used to find slope and intercept of the line that the perceptron represents?

    - A perceptron weights are used to represent a line.

The perceptron has inputs, weights, and an output. The weights are parameters that define the perceptron and they can be used to represent a line. In other words, the perceptron can be visualized as a line.

What does it mean for the perceptron to correctly classify every point in the training set?

Theoretically, it means that the perceptron predicted every label correctly.

Visually, it means that the perceptron found a /linear classifier/, or a /decision boundary,/ that separates the two distinct set of points in the training set.

*** Question 18
Which of the following statements is true for the SQL ~AS~ clause?

    - The SQL ~AS~ clause can rename a column name or a table name temporarily.

*** Question 19
True or False?

Results from an exploratory analysis can be generalized and used to draw conclusions about data that were not included in the analysis.

    - False

      That's right! Just like descriptive analysis, exploratory analysis is strictly concerned with the data at hand.

*** Question 20
How would you query for both the name and year columns from the albums table?

#+begin_src
SELECT name, year
FROM albums
#+end_src
